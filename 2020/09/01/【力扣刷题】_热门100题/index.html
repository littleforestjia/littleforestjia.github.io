<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1.两数之和tips：代码块中的注解、加粗、下划线部分为重点内容。  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9 因为 nums[0] + nums[1] &#x3D; 2">
<meta property="og:type" content="article">
<meta property="og:title" content="【力扣刷题】_热门100题">
<meta property="og:url" content="http://https//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/index.html">
<meta property="og:site_name" content="岩手县小森的博客">
<meta property="og:description" content="1.两数之和tips：代码块中的注解、加粗、下划线部分为重点内容。  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9 因为 nums[0] + nums[1] &#x3D; 2">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%5C9%E9%94%AE%E8%BE%93%E5%85%A5%E6%B3%95.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C2.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C3.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C2.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C3.png">
<meta property="article:published_time" content="2020-08-31T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-13T15:29:43.957Z">
<meta property="article:author" content="zju岩手县小森">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://https://littleforestjia.github.io/2020/09/01/【力扣刷题】_热门100题/"/>





  <title>【力扣刷题】_热门100题 | 岩手县小森的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岩手县小森的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">努力将眼前的每一天过得精彩</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://https://littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zju岩手县小森">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岩手县小森的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【力扣刷题】_热门100题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-01T00:00:00+08:00">
                2020-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">力扣刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a> </p>
<hr>
<h3 id="解读出来的隐藏信息："><a href="#解读出来的隐藏信息：" class="headerlink" title="解读出来的隐藏信息："></a>解读出来的隐藏信息：</h3><ul>
<li>给定数组不存在重复整数。</li>
<li>没说如果不存在对应答案怎么办，那么随便报错或者随便给一个答案都可以。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution3 s = <span class="keyword">new</span> Solution3();</span><br><span class="line">        <span class="keyword">int</span>[] array = s.twoSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,<span class="number">9</span>);</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]+<span class="string">","</span>+array[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong><u>暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - x 相等的目标元素。</u></strong></p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target == nums[i] + nums[j]) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有这样的两个元素则抛出异常，IllegalArgumentException异常类常被我们用来当作无法继续执行时输出提示的异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"没有这样的两个元素！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：两遍哈希表"><a href="#方法二：两遍哈希表" class="headerlink" title="方法二：两遍哈希表"></a>方法二：两遍哈希表</h3><p><strong>为了对运行时间复杂度进行优化，<u>我们需要一种更有效的方法来检查数组中是否存在目标元素</u>。</strong>如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？<strong>哈希表。</strong></p>
<p><strong>通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到 O(1)。</strong>哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p>
<p>一个简单的实现使用了两次迭代。<strong>在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</strong>注意，该目标元素不能是 nums[i]本身！</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>underscore：下划线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//因为这里我们要通过数值找到该数值在数组中的位置索引，</span></span><br><span class="line">            <span class="comment">//所以用数组数值作为键值对的key，索引作为键值对的value。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(complement) &amp;&amp; map.get(complement) != i)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"没有这样的两个元素！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h3><p>事实证明，我们可以一次完成。<strong>在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。</strong>如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> implement;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            implement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(implement))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(implement),i&#125;;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"没有这样的两个元素！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong><u>该题主要运用了哈希表搜索操作的时间复杂度为O(1)的性质，用哈希表代替暴力搜索，通过空间换时间减小了程序的时间复杂度。</u></strong></p>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重要示范案例：使两个对象变量指向同一对象，当使用其中一个变量改变对象后，另一个变量再调用该对象就是改变后的对象。</span></span><br><span class="line">        <span class="comment">//本质上就是两个对象变量指向的其实就是同一个内存地址，通过不同对象变量调用或改变对象时，操作的是同一块内存数据。</span></span><br><span class="line"><span class="comment">//        ListNode n1 = new ListNode(1);</span></span><br><span class="line"><span class="comment">//        ListNode n2 = n1;</span></span><br><span class="line"><span class="comment">//        System.out.println(n2.val);</span></span><br><span class="line"><span class="comment">//        n1.val = 2;</span></span><br><span class="line"><span class="comment">//        System.out.println(n2.val);</span></span><br><span class="line"></span><br><span class="line">        Solution s1 = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode listNode = s1.addTwoNumbers(l1,l2);</span><br><span class="line">        System.out.println(listNode.val+listNode.next.val*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法：初等数学"><a href="#方法：初等数学" class="headerlink" title="方法：初等数学"></a>方法：初等数学</h3><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。</p>
<p>伪代码如下：</p>
<ul>
<li>将当前结点初始化为返回列表的哑结点。</li>
<li>将进位 carry 初始化为 0。</li>
<li>将 p和 q分别初始化为列表 l1 和 l2 的头部。</li>
<li>遍历列表 l1 和 l2 直至到达它们的尾端。<ul>
<li>将 x 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。</li>
<li>将 y 设为结点 q 的值。如果 q已经到达 l2 的末尾，则将其值设置为 0。</li>
<li><strong>设定 sum = x + y + carry</strong>。</li>
<li>更新进位的值，carry = sum / 10。</li>
<li>创建一个数值为(sum mod 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</li>
<li>同时，将 p 和 q 前进到下一个结点。</li>
</ul>
</li>
<li>检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。</li>
<li>返回哑结点的下一个结点。</li>
</ul>
<p><strong><u>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</u></strong></p>
<p>时间复杂度：O(max(m, n))</p>
<p>空间复杂度：O(max(m, n))</p>
<p>dummy：虚假的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode next1 = l1;</span><br><span class="line">        ListNode next2 = l2;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使两个节点对象变量指向同一个节点，通过其中一个变量改变节点后，通过另一个变量获得的节点是改变后的节点。</span></span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (next1 != <span class="keyword">null</span> || next2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为两个链表所代表的整数的位数可能不一样，所以这里创建一个整型数来做一个判断。</span></span><br><span class="line">            <span class="comment">//重要：刷题的时候不要害怕创建新对象，要勇于多创建新对象，帮助我们理清解题思路。</span></span><br><span class="line">            <span class="keyword">int</span> x = (next1 != <span class="keyword">null</span>) ? next1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (next2 != <span class="keyword">null</span>) ? next2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next1 != <span class="keyword">null</span>) next1 = next1.next;</span><br><span class="line">            <span class="keyword">if</span> (next2 != <span class="keyword">null</span>) next2 = next2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哑节点后面的链表即为我们所需要的答案，哑节点的主要作用是帮助我们简化条件语句的编写。</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><u>这道题中就算是每个节点的整数属性都创建了一个新的变量x、y，刷题的时候就是要敢于去多创建变量，帮助自己理清思路，可以在后面理出具体思路之后，再去精简掉一些不必要的变量。</u></strong></li>
<li><strong><u>做链表相关数据结构时有一个好的方法，就是设置哑节点，这样能帮助我们更快的理清思路，也可以简化很多条件语句代码。</u></strong></li>
<li><strong><u>重要基础知识：使两个不同对象变量指向同一实例对象，当使用其中一个变量改变对象后，另一个变量再调用该对象时，调用的数据就是改变后的对象数据。</u></strong></li>
</ul>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> a = s.lengthOfLongestSubstring(<span class="string">"abcabcde"</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><h4 id="1-思路和算法"><a href="#1-思路和算法" class="headerlink" title="1.思路和算法"></a>1.思路和算法</h4><p><strong><u>我们不妨以示例一中的字符串 abcabcbb 为例，找出 从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。</u></strong></p>
<p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk；</li>
</ul>
<ul>
<li>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，</li>
<li>但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</li>
</ul>
<p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
<h4 id="2-判断重复字符"><a href="#2-判断重复字符" class="headerlink" title="2.判断重复字符"></a>2.判断重复字符</h4><p><strong><u>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合</u></strong>（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p>
<p>至此，我们就完美解决了本题。</p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(∣Σ∣)，其中∣Σ∣表示字符集的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; longSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> kr = i;</span><br><span class="line">            <span class="keyword">while</span> (kr &lt; n &amp;&amp; !longSet.contains(s.charAt(kr))) &#123;</span><br><span class="line">                <span class="comment">//String.charAt() 方法用于返回指定字符串索引处的字符。索引范围为从 0 到 length() - 1。</span></span><br><span class="line">                longSet.add(s.charAt(kr));</span><br><span class="line">                kr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用Math.max()方法比条件判断更加方便简洁。</span></span><br><span class="line">            answer = Math.max(answer,kr - i);</span><br><span class="line">            longSet.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><u>String.charAt() 方法用于返回指定字符串索引处的字符。索引范围为从 0 到 length() - 1。</u></strong></li>
<li><strong><u>在Java中一般我们要运用Map、Set等数据结构时，都是使用他们的实现类HashMap、HashSet。其中Set数据结构常用于存储不可重复的数据。</u></strong></li>
</ul>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p><strong>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</strong></p>
<p>示例 1：</p>
<p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p>
<p>示例 2：</p>
<p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p>
<p>示例 3：</p>
<p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p>
<p>示例 4：</p>
<p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p>
<p>示例 5：</p>
<p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>
<p>提示：</p>
<p>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p>
<p>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s1 = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">//还是要记住创建数组的几种常用写法。</span></span><br><span class="line">        System.out.println(s1.findMedianSortedArrays(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：自己写的（迭代）"><a href="#方法一：自己写的（迭代）" class="headerlink" title="方法一：自己写的（迭代）"></a>方法一：自己写的（迭代）</h3><p><strong>思路：创建一个新的数组，将原数组中的数值依次比较放入新数组中，合并成一个新的正序数组。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) &#123;</span><br><span class="line">            num = nums2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) &#123;</span><br><span class="line">            num = nums1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m &amp;&amp; j&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                num[i+j] = nums1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                num[i+j] = nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=j; x &lt; n; x++) &#123;</span><br><span class="line">                num[i+x] = nums2[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=i; x &lt; m; x++) &#123;</span><br><span class="line">                num[x+j] = nums1[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) num[(m+n)/<span class="number">2</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)num[(m+n)/<span class="number">2</span>-<span class="number">1</span>]+(<span class="keyword">double</span>)num[(m+n)/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h3><p><strong><u>如果对时间复杂度的要求有log，通常都需要用到二分法，这道题也可以通过二分查找实现。</u></strong></p>
<p>太过复杂，不再复现，详情见leetcode官网。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><u>创建数组的几种写法还是挺重要的，要记牢达到可以直接自己写出来的程度，比如此题中的<code>(new int[]{0,3,4}, new int[]{1,1,6,7,8})</code>。</u></strong></li>
<li><strong><u>如果对时间复杂度的要求有log，通常都需要用到二分法。</u></strong></li>
</ul>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></p>
<hr>
<h3 id="解读传来的隐藏信息："><a href="#解读传来的隐藏信息：" class="headerlink" title="解读传来的隐藏信息："></a>解读传来的隐藏信息：</h3><ul>
<li><strong>回文串是指这个字符串无论从左读还是从右读，所读的顺序是一样的，简而言之，回文串是左右对称的。</strong></li>
<li><strong>单字符字符串也是一个回文串。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.longestPalindrome(<span class="string">"12345676543211234"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法一：我自己想出来的-中心扩散法"><a href="#方法一：我自己想出来的-中心扩散法" class="headerlink" title="方法一：我自己想出来的(中心扩散法)"></a>方法一：我自己想出来的(中心扩散法)</h3><p><strong>思路：主要参考了</strong> <a href=".\力扣刷题_无重复字符的最长子串.md"></a><strong>这道题的方法，就是抽取每一个字符来进行枚举。对于奇数回文子串，设置两个指针分别从一个字符的两边往外移动，每一对字符都相等才可以继续往外移动。对于偶数回文子串，同样设置两个指针分别从两个相邻相等字符的两边往外移动，每一对字符都相等才可以继续往外移动。最后枚举找出了以每一个字符为中心或者每两个字符为中心的最大回文子串，然后从中找出长度最长的回文子串，即为输入字符串的最长回文子串。</strong></p>
<p>odd：奇数<br>even：偶数</p>
<p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> kl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oddcurr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> evencurr = <span class="number">0</span>;</span><br><span class="line">        String oddPalin = <span class="keyword">null</span>;</span><br><span class="line">        String evenPalin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//寻找奇数位的最长回文子串。</span></span><br><span class="line">            kl = i ;</span><br><span class="line">            kr = i ;</span><br><span class="line">            <span class="keyword">while</span> (kl &gt;-<span class="number">1</span> &amp;&amp; kr &lt; n &amp;&amp; s.charAt(kl) == s.charAt(kr)) &#123;</span><br><span class="line">                kl --;</span><br><span class="line">                kr ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (kr - kl - <span class="number">1</span> &gt; oddcurr) &#123;</span><br><span class="line">                oddcurr = kr - kl - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//String.substring(int i,int j)方法用于截取字符串中索引为i ~ j-1的字符串。</span></span><br><span class="line">                oddPalin = s.substring(kl + <span class="number">1</span>,kr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找偶数位的最长回文子串。</span></span><br><span class="line">            kl = i;</span><br><span class="line">            kr = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (kl &gt;-<span class="number">1</span> &amp;&amp; kr &lt; n &amp;&amp; s.charAt(kl) == s.charAt(kr)) &#123;</span><br><span class="line">                kl --;</span><br><span class="line">                kr ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (kr - kl - <span class="number">1</span> &gt; evencurr) &#123;</span><br><span class="line">                evencurr = kr - kl - <span class="number">1</span>;</span><br><span class="line">                evenPalin = s.substring(kl + <span class="number">1</span>,kr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oddcurr &gt; evencurr) <span class="keyword">return</span> oddPalin;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> evenPalin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法二：暴力法-（Brute-Force）"><a href="#方法二：暴力法-（Brute-Force）" class="headerlink" title="方法二：暴力法 （Brute Force）"></a>方法二：暴力法 （Brute Force）</h3><ul>
<li><strong><u>根据回文子串的定义，枚举所有长度大于等于 2 的子串，依次判断它们是否是回文；</u></strong></li>
<li>在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；</li>
<li>在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。</li>
</ul>
<p><strong>说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，可以使用暴力匹配算法检验我们编写的其它算法是否正确。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</strong></p>
<p>时间复杂度：O(N^3)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用方法String.toCharArray()把字符串分解为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//列举出字符串长度大于1的所有子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; max &amp;&amp; validPalindrome(array,i,j)) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判定字符串是否为回文子串。一般要先写好被调用方法，才能完成上面的调用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[m] != chars[n]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            m ++;</span><br><span class="line">            n --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>依然从回文串的定义展开讨论：</p>
<ul>
<li>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</li>
<li>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<ul>
<li>如果里面的子串是回文，整体就是回文串；</li>
<li>如果里面的子串不是回文串，整体就不是回文串。</li>
</ul>
</li>
</ul>
<p>即：<strong>在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。</strong>因此可以把「状态」定义为原字符串的一个子串是否为回文子串。</p>
<p>关键步骤：</p>
<ul>
<li><u><strong>定义状态：<code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文子串，这里子串 <code>s[i..j]</code> 定义为左闭右闭区间，可以取到 <code>s[i]</code> 和 <code>s[j]</code>。</strong></u></li>
<li><u><strong>定义状态转移方程：<code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></strong></u></li>
</ul>
<p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(N^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先要定义一个状态，用来作为是否达到目标的判断条件，也是状态转移的关键主体，动态规划的核心。</span></span><br><span class="line">        <span class="comment">//此处用对应子串是否为回文串作为状态，考虑所有子串，则用一个二位表来表示。</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非常重要，对于动态规划的嵌套循环，一定要是j在外面，i在里面，这样才能先把长度小的子串的回文状态判断好。</span></span><br><span class="line">        <span class="comment">//如果是先判断长的子串的回文状态，那么它需要用到短的子串的回文状态，这就要求短的子串的状态判断必须都先于长的子串。</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; len - 1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//  for (int j = i + 1; j &lt; len; j++) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] != array[j]) dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i &lt; <span class="number">3</span>) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><u>String.substring(int i,int j)方法用于截取字符串中索引为i ~ j-1的字符串。</u></strong></li>
<li><strong><u>String.toCharArray()方法用于把字符串分解为字符数组。</u></strong></li>
<li><strong><u>对于这种找子串的题目，有一种比较常用的思路：对数据中每个元素进行暴力枚举找出要求子串，然后在枚举出的所有子串中比较选出最符合要求的子串输出。</u></strong></li>
<li><strong><u>刷题时一定要注意边界特殊情况，每次循环时，将索引0、1、end位置的元素代进去看看符不符合要求，不符合要求则单独拿出来用编写特殊语句。</u></strong></li>
<li><strong><u>刷题时，一般先写好被调用方法，才能完成调用方法的编写，至少一定要先定义好被调用方法的方法名、参数列表、返回值类型。</u></strong></li>
<li><strong><u>动态规划中的嵌套循环的执行顺序很重要，具体见Solution2中注释。</u></strong></li>
</ul>
<h2 id="10-正则表达式匹配-非常重要"><a href="#10-正则表达式匹配-非常重要" class="headerlink" title="10.正则表达式匹配(非常重要)"></a>10.正则表达式匹配(非常重要)</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>
<p>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
<p>示例 3:</p>
<p>输入:<br>s = “ab”<br>p = “.*”<br>输出: true<br>解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>
<p>示例 4:</p>
<p>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:</p>
<p>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p>
<p>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1 s1 = <span class="keyword">new</span> Solution1();</span><br><span class="line">        <span class="keyword">boolean</span> b1 = s1.isMatch(<span class="string">"aaa"</span>,<span class="string">"a*a"</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><h4 id="动态规划的重要步骤"><a href="#动态规划的重要步骤" class="headerlink" title="动态规划的重要步骤"></a>动态规划的重要步骤</h4><ul>
<li><p>定义状态：比如本题中用<code>dp[i][j]</code>来表示长度为i的字符串s和长度为j的正则表达式p是否匹配。</p>
</li>
<li><p>思考状态转移方程：也就是由简单状态得到复杂一级状态的计算规则，比如本题中的下图：</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png" alt></p>
</li>
<li><p>初始化边界状态(编写程序时的难点)：比如本题中的<code>dp[0][0]=true</code>和一些特殊的边界情况。</p>
</li>
</ul>
<h4 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h4><p><strong>使用类似于枚举的暴力法做不出这道题，相比于暴力法，使用动态规划最大的优点就是多出了一个or，可以将<code>.*</code>与任意个字符相匹配的所用情况都囊括进来。</strong></p>
<p><strong>时间复杂度：O(mn)，我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。</strong></p>
<p><strong>空间复杂度：O(mn)，即为存储所有状态使用的空间。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意该二维数组角标的含义，dp[0][0]表示长度都为0的两个字符串的匹配结果，</span></span><br><span class="line">        <span class="comment">//所以dp[m][n]才是表示长度为m、n的两个字符串的匹配结果。</span></span><br><span class="line">        <span class="comment">//boolean初始构造函数默认赋值为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定初始边界值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划的本质就是从最开始的，最容易得到的边界状态值，遵循相同的规则不断由下向上计算得出最终值。</span></span><br><span class="line">        <span class="comment">//一开始一直错的原因：边界dp[0][j]并不全部都是false，当s为空，p为一个字符加上*时也是匹配的，</span></span><br><span class="line">        <span class="comment">//所以一定要把这种情况考虑进去，所以此处i从0开始考虑。(实际上就是在判断字符相等之前加上i&gt;0，使得上述情况对于的状态为true。)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//以*开头的字符串相当于直接忽略第一个*字符。</span></span><br><span class="line">                    <span class="keyword">if</span> (j==<span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; match(s.charAt(i-<span class="number">1</span>),p.charAt(j-<span class="number">2</span>))) &#123;</span><br><span class="line">                        <span class="comment">//此处的or非常重要，通过这个or可以将 .*与任意个字符相匹配 的所用情况都囊括进来。</span></span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; match(s.charAt(i-<span class="number">1</span>),p.charAt(j-<span class="number">1</span>))) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="****总结"></a>****总结</h3><ul>
<li><u><strong>使用动态规划时，一定要注意二维数组角标的含义，本题中<code>dp[0][0]</code>表示长度都为0的两个字符串的匹配结果，所以<code>dp[m][n]</code>才是表示长度为m、n的两个字符串的匹配结果。</strong></u></li>
<li><u><strong>boolean初始构造函数默认赋值为false。</strong></u></li>
<li><u><strong>动态规划的本质就是从最开始的，最容易得到的边界状态值，遵循相同的规则不断由下向上计算得出最终值。</strong></u></li>
<li><u><strong>考虑边界状态时，一定要注意到边界<code>dp[0][j]</code>并不全部都是false。当s为空，p为一个字符加上*时也是匹配的这种特殊情况。</strong></u></li>
<li><u><strong>本题中的or非常重要，通过这个or可以将<code>.*</code>与任意个字符相匹配的所用情况都囊括进来，这也是这道题一定要用动态规划的原因。</strong></u></li>
</ul>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p>示例：</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
<p>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1 s = <span class="keyword">new</span> Solution1();</span><br><span class="line">        System.out.println(s.maxArea(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：我自己写的-暴力法"><a href="#方法一：我自己写的-暴力法" class="headerlink" title="方法一：我自己写的(暴力法)"></a>方法一：我自己写的(暴力法)</h3><p>按顺序已每个数为左边，它右边的每个数再按顺序为右边，枚举出所有面积值，比较选出最大的。</p>
<p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                h = height[i] &lt; height[j] ? height[i] : height[j];</span><br><span class="line">                w = j - i;</span><br><span class="line">                maxWater = Math.max(maxWater,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>在初始时，左右指针分别指向数组的左右两端，计算出盛水面积。</p>
<p><strong><u>此时我们需要移动一个指针。移动哪一个呢？应该移动对应数字较小的那个指针，因为由于容纳的水量是由<code>两个指针指向的数字中较小值 * 指针之间的距离</code>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」只可能减小，不可能增加，后者「指针之间的距离」会减小，那么这个乘积只能减小。因此，我们移动数字较小的那个指针，盛水面积才有可能增大。</u></strong></p>
<p>重复以上步骤，直到两个指针重合，比较选择出最大的盛水面积。</p>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            maxWater = Math.max((height[left] &lt; height[right] ? height[left] : height[right])*(right-left),maxWater);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1 s1 = <span class="keyword">new</span> Solution1();</span><br><span class="line">        System.out.println(s1.threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：排序-三重循环"><a href="#方法一：排序-三重循环" class="headerlink" title="方法一：排序+三重循环"></a>方法一：排序+三重循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; out = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用工具类Arrays，它的sort()方法可用对多种数据类型数组按默认规则或者自定义规则排序。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三重循环枚举三元组，并判断是否符合要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//避免产生重复。</span></span><br><span class="line">            <span class="comment">//注意此处的判断条件一定不能写成nums[i] == nums[i + 1]，不然会漏掉一些有相同元素的符合要求的三元数组。后面两个判断条件同理。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j  &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k  &gt; j + <span class="number">1</span> &amp;&amp; nums[k - <span class="number">1</span>] == nums[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; subOut = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                        subOut.add(nums[i]);</span><br><span class="line">                        subOut.add(nums[j]);</span><br><span class="line">                        subOut.add(nums[k]);</span><br><span class="line">                        out.add(subOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：排序-双指针-自己写的"><a href="#方法二：排序-双指针-自己写的" class="headerlink" title="方法二：排序+双指针(自己写的)"></a>方法二：排序+双指针(自己写的)</h3><p>自己写的，但是写错了，不是真的双指针，主要用来与方法三进行对比，方便理解双指针的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用工具类Arrays，它的sort()方法可用对多种数据类型数组按默认规则或者自定义规则排序。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针法找出符合要求的三元组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j  &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//j为左指针，k为右指针，因为k&gt;j这一双指针限制条件，使得j、k这两重循环加在一起时间复杂度是O(n)，而不是O(n^2)。</span></span><br><span class="line">                <span class="keyword">while</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; subOut = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    subOut.add(nums[i]);</span><br><span class="line">                    subOut.add(nums[j]);</span><br><span class="line">                    subOut.add(nums[k]);</span><br><span class="line">                    out.add(subOut);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：排序-双指针"><a href="#方法三：排序-双指针" class="headerlink" title="方法三：排序+双指针"></a>方法三：排序+双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用工具类Arrays，它的sort()方法可用对多种数据类型数组按默认规则或者自定义规则排序。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针法找出符合要求的三元组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//j为左指针，k为右指针，因为k&gt;j这一双指针限制条件，使得j、k这两重循环加在一起时间复杂度是O(n)，而不是O(n^2)。</span></span><br><span class="line">            <span class="comment">//非常重要：一定要把左、右指针的定义放在循环的外面，是否满足条件的判断一定要放在第一层循环中，且一旦左右指针相遇就跳出循环。</span></span><br><span class="line">            <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j  &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == k) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; subOut = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    subOut.add(nums[i]);</span><br><span class="line">                    subOut.add(nums[j]);</span><br><span class="line">                    subOut.add(nums[k]);</span><br><span class="line">                    out.add(subOut);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><u><strong>工具类Arrays的sort()方法可用对多种数据类型数组按默认规则或者自定义规则排序。</strong></u></li>
<li><u><strong>三重循环可用于枚举三元素数组。</strong></u></li>
<li><u><strong>双指针法中左、右指针的定义一定要放在循环的外面，且一旦左右指针相遇就要停止循环。</strong></u></li>
</ul>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%5C9%E9%94%AE%E8%BE%93%E5%85%A5%E6%B3%95.png" alt></p>
<p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s1 = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s1.letterCombinations(<span class="string">"23"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：递归回溯法-自己写的"><a href="#方法一：递归回溯法-自己写的" class="headerlink" title="方法一：递归回溯法(自己写的)"></a>方法一：递归回溯法(自己写的)</h3><p><strong>分析易得该题的答案输出模式为：在上一步的基础之上添加几种可能形成下一级，通过这种方式逐渐增多。</strong></p>
<p><strong>这种模式一下子就想到了<code>22.括号生成</code>中使用过的递归回溯法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.length();</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认刚创建的列表就是[]，表示内部不含任何子元素，但该列表也不是null。</span></span><br><span class="line">        <span class="comment">//注意stringList=[]和stringList=null的意义是完全不一样，第一个表示该列表在内存中真实存在，第二个表示该列表变量不指向真正存在的内存数据。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> stringList;</span><br><span class="line">        combinations(<span class="keyword">new</span> <span class="keyword">char</span>[n],<span class="number">0</span>,stringList,digits);</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combinations</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> index, List&lt;String&gt; stringList,String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == chars.length) &#123;</span><br><span class="line">            stringList.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (digits.charAt(index)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'2'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'a'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'b'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'c'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'3'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'d'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'e'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'f'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'4'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'g'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'h'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'i'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'5'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'j'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'k'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'l'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'6'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'m'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'n'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'o'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'7'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'p'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'q'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'r'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'s'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'8'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'t'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'u'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'v'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'9'</span> :</span><br><span class="line">                    chars[index] = <span class="string">'w'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'x'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'y'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    chars[index] = <span class="string">'z'</span>;</span><br><span class="line">                    combinations(chars,index + <span class="number">1</span>,stringList,digits);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归回溯法"><a href="#方法二：递归回溯法" class="headerlink" title="方法二：递归回溯法"></a>方法二：递归回溯法</h3><p><strong>官方版本，主要就是使用了哈希表，使写法更加简便。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">            put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">            put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">            put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">            put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">            put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits.charAt(index);</span><br><span class="line">            String letters = phoneMap.get(digit);</span><br><span class="line">            <span class="keyword">int</span> lettersCount = letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><u><strong>递归回溯法很重要很好用，一定要背出编写过程。</strong></u></li>
<li><u><strong>ArrayList()构造方法默认创建的动态数组就是[]，表示内部不含任何子元素，但该动态数组也不是null。注意stringList=[]和stringList=null的意义是完全不一样：第一个表示该动态数组变量指向在内存中真实存在的数据，只不过该动态数组内部还没有存储元素；第二个表示该动态数组变量根本不指向真正存在的内存数据。</strong></u></li>
<li><u><strong>刷题时Map的实现类一般就用HashMap。</strong></u></li>
</ul>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
<p>说明：<br>给定的 n 保证是有效的。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：快慢指针-自己写的"><a href="#方法一：快慢指针-自己写的" class="headerlink" title="方法一：快慢指针(自己写的)"></a>方法一：快慢指针(自己写的)</h3><p><strong>思路：留一个滞后指针，前置指针先走，走到一定位置后，两个指针再同速前行，使得前置指针到达链表末尾时，滞后指针刚好指在需要删除节点的前一个节点。</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(0)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode first = <span class="keyword">new</span> ListNode();</span><br><span class="line">        first.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边界特殊情况无论是什么时候都要考虑。</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        ListNode delete = first;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index == n) flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) delete = delete.next;</span><br><span class="line">        &#125;</span><br><span class="line">        delete.next = delete.next.next;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p><strong>我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;ListNode&gt;();</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev = stack.peek();</span><br><span class="line">        prev.next = prev.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><u>无论是什么时候都要考虑边界特殊情况。</u></strong></li>
<li><strong><u>考虑倒数相关问题时，可以先想一下能不能使用栈来解决。</u></strong></li>
</ul>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:<br>输入: “()”<br>输出: true</p>
<p>示例 2:<br>输入: “()[]{}”<br>输出: true</p>
<p>示例 3:<br>输入: “(]”<br>输出: false</p>
<p>示例 4:<br>输入: “([)]”<br>输出: false</p>
<p>示例 5:<br>输入: “{[]}”<br>输出: true</p>
<p>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.isValid(<span class="string">"&#123;&#125;[]&#125;&#123;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：自己写的-栈"><a href="#方法一：自己写的-栈" class="headerlink" title="方法一：自己写的(栈)"></a>方法一：自己写的(栈)</h3><p><strong><u>将字符串中字符一个一个放到栈中，当遇到成对的括号就一起出栈，看最后栈是否为空，为空则说明符合要求，不为空则说明不符合要求。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Character[] array = <span class="keyword">new</span> Character[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            array[i] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(array[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(array[i]);</span><br><span class="line">                <span class="comment">//跳过本次循环，继续下一次循环用continue；跳出循环用break；</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//非常重要：Character.equals()方法的输入参数一定要是单引号表示字符，如果是双引号会被识别成字符串，该方法会直接返回false。</span></span><br><span class="line">            <span class="comment">//char没有equals()方法，Character才有，所以我们这里也转换成Character[]；这两者都不能用==、！=等比较运算符。</span></span><br><span class="line">            <span class="keyword">if</span> (array[i].equals(<span class="string">')'</span>) &amp;&amp; stack.peek().equals(<span class="string">'('</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Stack.peek()方法运行时栈不能为空，否则会报错。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[i].equals(<span class="string">']'</span>) &amp;&amp; stack.peek().equals(<span class="string">'['</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[i].equals(<span class="string">'&#125;'</span>) &amp;&amp; stack.peek().equals(<span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法二：栈-哈希表"><a href="#方法二：栈-哈希表" class="headerlink" title="方法二：栈+哈希表"></a>方法二：栈+哈希表</h3><p>我们对给定的字符串 s 进行遍历，当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>
<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。<strong>为了快速判断括号的类型，我们可以使用哈希映射（HashMap）存储每一种括号。哈希映射的键为右括号，值为相同类型的左括号。</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n+∣Σ∣)，其中Σ 表示字符集中不同字符个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Character c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c)) stack.push(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//很关键的一个细节，只要遇到了右括号，它必须马上和栈顶元素匹配闭合相消，</span></span><br><span class="line">            <span class="comment">//这样才可能是true，一旦有一个右括号没有和栈定元素闭合就是false了。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || !map.get(stack.peek()).equals(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><u><strong>跳过本次循环，继续下一次循环用continue；跳出循环用break。</strong></u></li>
<li><u><strong>Stack.peek()方法运行时栈不能为空，否则会报错。</strong></u></li>
<li><u><strong>char没有equals()方法，Character才有；这两种数据类型都不能用==、!=等比较运算符。</strong></u></li>
<li><u><strong>Character.equals()方法的输入参数一定要是单引号表示字符，如果是双引号会被识别成字符串，该方法会直接返回false。</strong></u></li>
<li><strong><u>遍历输入字符串中字符，只要遇到了右括号，它必须马上和栈顶元素匹配闭合相消，这样才可能是true，一旦有一个右括号没有和栈定元素闭合就是false了。</u></strong></li>
</ul>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p>
<hr>
<h3 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h3><p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E6%A8%A1%E5%9E%8B.png" alt></p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p>
<p><strong><u>同时需要考虑边界情况，如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。</u>否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</strong></p>
<p>时间复杂度：O(n + m)，其中 nn 和 mm 分别为两个链表的长度。</p>
<p>空间复杂度：O(n + m)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法二：迭代法"><a href="#方法二：迭代法" class="headerlink" title="方法二：迭代法"></a>方法二：迭代法</h3><p><strong><u>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</u></strong></p>
<p>时间复杂度：O(n + m)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode firstNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode newNode = firstNode;</span><br><span class="line">        ListNode upNode = l1;</span><br><span class="line">        ListNode downNode = l2;</span><br><span class="line">        <span class="keyword">while</span> (upNode != <span class="keyword">null</span> &amp;&amp; downNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (upNode.val &lt;= downNode.val) &#123;</span><br><span class="line">                newNode.next = upNode;</span><br><span class="line">                newNode = upNode;</span><br><span class="line">                upNode = upNode.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newNode.next = downNode;</span><br><span class="line">                newNode = downNode;</span><br><span class="line">                downNode = downNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (upNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.next = downNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = upNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><u>方法的输入参数，比如本题中的l1、l2是可以改变的，比如本题中<code>l1=l1.next;</code>，这样可以少定义几个节点变量，减少空间复杂度。</u></strong></li>
</ul>
<ul>
<li><strong><u>递归法只要递归模型建立好了，就不用去考虑内部运行机制了。就像这道题，已经知道要用递归法的情况下，我还在思考递归函数内部的while循环方法怎么写，这个思路明显就是错了，都已经用递归了，当然就不需要用循环了，也不需要再考虑内部执行机制了。</u></strong></li>
<li><strong><u>递归法其实最重要的或者说最难的一点，是边界情况的编写或特殊情况的编写，比如此处的一条链表到尾端时的处理，通过条件语句判断出来。一般边界情况要尽量编写的简练。</u></strong></li>
<li><strong><u>迭代法中又用到了哑节点的概念，一般涉及到链表的题目，要返回链表时，都是通过设置哑节点，返回哑节点的下一个节点。</u></strong></li>
</ul>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<code>有效的</code>括号组合。</p>
<p>示例：</p>
<p>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a></p>
<hr>
<h3 id="方法一：暴力法-1"><a href="#方法一：暴力法-1" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong>枚举所有种类的字符数组，共2^2n种，检验出其中有效的，放入结果数组中。</strong></p>
<p><strong><u>这种思路的关键部分是，每个位置只能是<code>(</code>或<code>)</code>这两种，那么我们要枚举所有字符串的方法就是从null开始，在字符串后添加一个<code>(</code>或<code>)</code>，然后又在每一种情况下，在字符串后添加一个<code>(</code>或<code>)</code>，一直递归，直到字符串长度达到预期长度。</u></strong></p>
<p>时间复杂度：O((2^2n)n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        generateString(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>*n],<span class="number">0</span>,stringList);</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个递归真是太巧妙了，这谁想的出来啊！！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateString</span><span class="params">(<span class="keyword">char</span>[] charList,<span class="keyword">int</span> nowLength,List&lt;String&gt; stringList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowLength == charList.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(charList)) &#123;</span><br><span class="line">                stringList.add(<span class="keyword">new</span> String(charList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            charList[nowLength] = <span class="string">'('</span>;</span><br><span class="line">            generateString(charList, nowLength + <span class="number">1</span>, stringList);</span><br><span class="line">            charList[nowLength] = <span class="string">')'</span>;</span><br><span class="line">            generateString(charList, nowLength + <span class="number">1</span>, stringList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//该方法主要用于检验一段括号序列，组合在一起是否是有效括号字符串。</span></span><br><span class="line">    <span class="comment">//主要有两个判断条件：</span></span><br><span class="line">    <span class="comment">//1.每一个包含第一个括号的子序列中左括号个数不能小于右括号个数，</span></span><br><span class="line">    <span class="comment">//因为无论后面再加上多少个左括号，都不能和前面多出来的右括号配对相消。</span></span><br><span class="line">    <span class="comment">//2.总的左右括号个数一定要相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[] charList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:charList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>) &#123;balance++;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;balance--;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一旦括号序列中包含第一个括号的子序列中，左括号个数小于右括号个数，那说明该括号序列一定是无效的。</span></span><br><span class="line">            <span class="keyword">if</span>(balance &lt; <span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p><code>public void generateString(char[] charList,int nowLength,List&lt;String&gt; stringList)</code>该方法中：</p>
<ul>
<li><u><strong>第一个参数最初为一个空的字符串数组，主要用来提供字符串预期长度，并给不断添加左右括号的字符数组提供一个载体；</strong></u></li>
<li><u><strong>第二个参数表示现在字符数组中已经添加了几个左右括号字符了；</strong></u></li>
<li><u><strong>第三个参数主要为枚举结果提供一个载体，一般不会在递归函数中创建新的变量，一般先在递归函数外面定义好变量，将该变量作为参数传入递归函数，由递归函数改变它，递归函数也可以通过这种方式传出运行结果。</strong></u></li>
</ul>
</li>
<li><p><u><strong>一种新的检验括号字符串是否有效的方法：</strong></u></p>
<ol>
<li><u><strong>每一个包含第一个括号的子序列中左括号个数不能小于右括号个数，因为无论后面再加上多少个左括号，都不能和前面多出来的右括号配对相消。</strong></u></li>
<li><u><strong>总的左右括号个数一定要相等。</strong></u></li>
</ol>
<p><u><strong>只要满足以上两个条件，就是有效括号字符串。</strong></u></p>
</li>
</ul>
<h3 id="方法二：回溯法"><a href="#方法二：回溯法" class="headerlink" title="方法二：回溯法"></a>方法二：回溯法</h3><p><strong>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 <code>(</code> 或 <code>)</code>，而不是像方法一那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点：</strong></p>
<ol>
<li><strong>如果左括号数量不大于 n，我们可以放一个左括号。</strong></li>
<li><strong>如果右括号数量小于左括号的数量，我们可以放一个右括号。</strong></li>
</ol>
<p><strong><u>以上两个条件优先级相同，一个字符串同时满足就分裂成两种情况。</u></strong></p>
<p><u><strong>这个思路本质上其实就是设定一种左右括号添加顺序的规则，使得遵守这种括号添加规则的字符串到最后都是有效的。</strong></u></p>
<p>时间复杂度：O((4^n)/sqrt(n))</p>
<p>空间复杂度：O(n)</p>
<p><strong>我自己照这个思路在方法一的基础上写的：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrack(<span class="keyword">new</span> <span class="keyword">char</span>[n*<span class="number">2</span>],<span class="number">0</span>,<span class="number">0</span>,stringList);</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] charList,<span class="keyword">int</span> leftNumber,<span class="keyword">int</span> rightNumber,List&lt;String&gt; stringList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件，就是添加括号达到预期数目。</span></span><br><span class="line">        <span class="keyword">if</span>(leftNumber+rightNumber == charList.length) &#123;</span><br><span class="line">            stringList.add(<span class="keyword">new</span> String(charList));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftNumber*<span class="number">2</span> &lt; charList.length) &#123;</span><br><span class="line">            charList[leftNumber+rightNumber] = <span class="string">'('</span>;</span><br><span class="line">            backTrack(charList,leftNumber+<span class="number">1</span>,rightNumber,stringList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rightNumber &lt; leftNumber) &#123;</span><br><span class="line">            charList[leftNumber+rightNumber] = <span class="string">')'</span>;</span><br><span class="line">            backTrack(charList,leftNumber,rightNumber+<span class="number">1</span>,stringList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>力扣官方答案：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">'('</span>);</span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">')'</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><u><strong>注意我自己写的和官方两种递归方法的差别：</strong></u><ol>
<li><u><strong>我自己写的递归方法中，是没有在递归终止语句后面加上return的，其实这两种写法中，加不加都无所谓，效果是一样的。但是我们要知道区别，如果不加return，则要通过条件语句确保递归终止语句后面的代码不会再执行了。</strong></u></li>
<li><u><strong>(非常重要)官方方法中，后面两个包含递归方法的if代码块中是通过添加<code>cur.append(&#39;(&#39;);</code>来改变字符串的，执行第一个代码块时，从递归方法中出来后必须先把添加的字符去掉<code>cur.deleteCharAt(cur.length() - 1);</code>，再进入第二个代码块中执行添加操作；而我自己写的方法是直接给该索引位置的字符重新赋值<code>charList[leftNumber+rightNumber] = &#39;)&#39;;</code>，所以不用先删掉之前添加的字符，重新赋值会直接覆盖原来的字符。</strong></u></li>
</ol>
</li>
</ul>
<h3 id="方法三：动态规划递归（还没自己实现）"><a href="#方法三：动态规划递归（还没自己实现）" class="headerlink" title="方法三：动态规划递归（还没自己实现）"></a>方法三：动态规划递归（还没自己实现）</h3><p><strong>任何一个括号序列都一定是由<code>(</code>开头，并且第一个<code>(</code>一定有一个唯一与之对应的<code>)</code>。这样一来，每一个括号序列可以用<code>(a)b</code>来表示，其中<code>a</code>与<code>b</code>分别是一个合法的括号序列（可以为空）。</strong></p>
<p><u><strong>那么，要生成所有长度为2*n的括号序列，我们定义一个函数方法generate(n)来返回所有可能的括号序列。那么在函数 generate(n) 的过程中：</strong></u></p>
<ul>
<li><u><strong>我们需要枚举与第一个 ( 对应的 ) 的位置 2 * i + 1；</strong></u></li>
<li><u><strong>递归调用 generate(i) 即可计算 a 的所有可能性；</strong></u></li>
<li><u><strong>递归调用 generate(n - i - 1) 即可计算 b 的所有可能性；</strong></u></li>
<li><u><strong>遍历 a 与 b 的所有可能性并拼接，即可得到所有长度为 2 * n 的括号序列。</strong></u></li>
</ul>
<p><strong>为了节省计算时间，我们在每次 generate(i) 函数返回之前，把返回值存储起来，下次再调用 generate(i) 时可以直接返回，不需要再递归计算。</strong></p>
<p>时间复杂度：O((4^n)/sqrt(n))</p>
<p>空间复杂度：O((4^n)/sqrt(n))</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generate(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ArrayList[] cache = <span class="keyword">new</span> ArrayList[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[n] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="string">""</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String left: generate(c)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String right: generate(n - <span class="number">1</span> - c)) &#123;</span><br><span class="line">                        ans.add(<span class="string">"("</span> + left + <span class="string">")"</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23.合并K个升序链表"></a>23.合并K个升序链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。 </p>
<p>示例 1：<br>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>示例 2：<br>输入：lists = []<br>输出：[]</p>
<p>示例 3：<br>输入：lists = [[]]<br>输出：[]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：递归-顺序合并-自己写的"><a href="#方法一：递归-顺序合并-自己写的" class="headerlink" title="方法一：递归+顺序合并(自己写的)"></a>方法一：递归+顺序合并(自己写的)</h3><p><strong>思路：使用递归法合并两个升序链表，然后一个个将剩下的链表按同样的方法合并进来。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        ListNode out = mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n ;i++) &#123;</span><br><span class="line">            out = mergeTwoLists(out,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><u>递归和迭代的时间复杂度相同，迭代空间复杂度比递归低。</u></strong></li>
</ul>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<p>链接：<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-permutation</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>字典序大小：不同排列的大小关系是从左到右逐个比较对应的数字的先后来决定的。其实就是从左到右依次比较每一位上的字符，一旦比较出大小不同则在该位上大的序列大于另一个序列。例如对于5个数字的排列 12354和12345，排列12345小于12354。按照这样的规定，5个数字的所有的排列中最小的是12345，最大的是 54321。</u></strong></p>
<h3 id="方法一：一边扫描-栈"><a href="#方法一：一边扫描-栈" class="headerlink" title="方法一：一边扫描+栈"></a>方法一：一边扫描+栈</h3><p><u><strong>我们需要从右边找到第一对两个连续的数字 a[i] 和 a[i-1]，它们满足 a[i]&gt;a[i-1]。现在，没有对 a[i-1]右侧的重新排列可以创建更大的排列，因为该子数组由数字按降序组成。因此，我们只需要重新排列 a[i-1] 右边的数字，包括它自己。</strong></u></p>
<p><u><strong>我们想要创建比当前更大的排列。因此，我们需要将数字 a[i-1] 替换为位于其右侧区域的数字中比它更大的数字中最小的数字a[j]。</strong></u></p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%5C1.png" alt></p>
<p><u><strong>我们交换数字 a[i-1]和 a[j]。我们现在在索引i-1处有正确的数字。但目前的排列仍然不是我们正在寻找的排列。我们需要通过仅使用 a[i-1]右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。</strong></u></p>
<p><u><strong>但是，请记住，在从右侧扫描数字时，我们只是继续递减索引直到我们找到 a[i]和 a[i-1] 这对数。其中，a[i] &gt; a[i-1]。因此，a[i-1]右边的所有数字都已按降序排序。此外，交换 a[i-1]和 a[j]并未改变该顺序。因此，我们只需要反转 a[i-1]之后的数字，以获得下一个最小的字典排列。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从尾端开始寻找后一个数比前一个数大的相邻两数。</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; nums[n] &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经是字典序中最大的排列，则需要将数字序列中元素顺序倒转过来，变成字典序中最小的排列。</span></span><br><span class="line">        <span class="comment">//使用栈来倒转排列顺序。</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                nums[i] = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; nums.length &amp;&amp; nums[m] &gt; nums[n-<span class="number">1</span>]) &#123;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[m - <span class="number">1</span>];</span><br><span class="line">            nums[m - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">            nums[n - <span class="number">1</span>] = temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; nums.length; i++) &#123;</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; nums.length; i++) &#123;</span><br><span class="line">                nums[i] = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
<p>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution3 s1 = <span class="keyword">new</span> Solution3();</span><br><span class="line">        System.out.println(s1.longestValidParentheses(<span class="string">")()())"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：枚举-栈-自己写的"><a href="#方法一：枚举-栈-自己写的" class="headerlink" title="方法一：枚举+栈(自己写的)"></a>方法一：枚举+栈(自己写的)</h3><p>不太行，方法上感觉没问题，但是超出了时间限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i + max; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j - i) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ValidParentheses(s.substring(i,j))) &#123;</span><br><span class="line">                        max = j - i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用栈判断括号字符串是不是有效括号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(<span class="string">'('</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非常重要的总结："><a href="#非常重要的总结：" class="headerlink" title="非常重要的总结："></a>非常重要的总结：</h3><p><u><strong>判断括号字符串是否有效的方法：</strong></u></p>
<ol>
<li><u><strong>栈</strong></u></li>
<li><u><strong>同时满足以下两个条件：</strong></u><ul>
<li><u><strong>每一个包含第一个括号的子序列中左括号个数不能小于右括号个数，因为无论后面再加上多少个左括号，都不能和前面多出来的右括号配对相消。</strong></u></li>
<li><u><strong>总的左右括号个数一定要相等。</strong></u></li>
</ul>
</li>
</ol>
<p><u><strong>方法三、方法四也正是有这两种方法衍生出来的。</strong></u></p>
<h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><u><strong>时间复杂度：O(n)</strong></u></p>
<p><u><strong>空间复杂度：O(n)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义状态dp[i]表示 以索引位置i处字符为尾端的有效括号子串的长度</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定初始边界值</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'('</span> &amp;&amp; s.charAt(<span class="number">1</span>) == <span class="string">')'</span> ) &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            max = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = (i - dp[i-<span class="number">1</span>] - <span class="number">1</span> == <span class="number">0</span>) ? dp[i - <span class="number">1</span>] + <span class="number">2</span> : dp[i - <span class="number">1</span>] + dp[i - dp[i-<span class="number">1</span>] -<span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：栈"><a href="#方法三：栈" class="headerlink" title="方法三：栈"></a>方法三：栈</h3><p><strong><u>重要：栈底必须放置当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样才能计算出最长有效括号子串的长度。也就是说除了栈底，栈中其他元素只能是右括号的下标。</u></strong></p>
<p><u><strong>时间复杂度：O(n)</strong></u></p>
<p><u><strong>空间复杂度：O(n)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在最开始时在栈底放一个-1，放置先把左括号的下标放到栈底去了。</span></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个逻辑关系写得太妙了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max,i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法四：判断括号字符串有效的两个条件"><a href="#方法四：判断括号字符串有效的两个条件" class="headerlink" title="方法四：判断括号字符串有效的两个条件"></a>方法四：判断括号字符串有效的两个条件</h3><p><strong><u>重要：从左往右遍历一遍之后，还有从右往左遍历一遍。因为如果只从左往右遍历一遍，则会忽略掉左括号数量永远大于右括号数量这种情况中的有效括号子串。</u></strong></p>
<p><u><strong>时间复杂度：O(n)</strong></u></p>
<p><u><strong>空间复杂度：O(1)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                    left = <span class="number">0</span>;</span><br><span class="line">                    right = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == left) &#123;</span><br><span class="line">                    max = Math.max(max,<span class="number">2</span> * right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反向在遍历一次</span></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                    left = <span class="number">0</span>;</span><br><span class="line">                    right = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (right == left) &#123;</span><br><span class="line">                    max = Math.max(max,<span class="number">2</span> * right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p><strong><u>非常重要：本题是有效括号题的典范。</u></strong></p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个升序排列的整数数组 nums ，和一个整数 target 。<br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。<br>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>示例 1：<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p>
<p>示例 2：<br>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p>
<p>示例 3：<br>输入：nums = [1], target = 0<br>输出：-1</p>
<p>提示：<br>1 &lt;= nums.length &lt;= 5000<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 中的每个值都 独一无二<br>nums 肯定会在某个点上旋转<br>-10^4 &lt;= target &lt;= 10^4</p>
<p>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1 s1 = <span class="keyword">new</span> Solution1();</span><br><span class="line">        System.out.println(s1.search(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：二分搜索"><a href="#方法一：二分搜索" class="headerlink" title="方法一：二分搜索"></a>方法一：二分搜索</h3><p><strong>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</strong></p>
<p><strong>这启示我们可以在常规二分搜索的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</strong></p>
<ul>
<li><u><strong>如果 [l, mid - 1] 是有序数组，且 target 的大小满足[nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。</strong></u></li>
<li><u><strong>如果 [mid, r] 是有序数组，且 target 的大小满足(nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</strong></u></li>
</ul>
<p><u><strong>时间复杂度：O(logn)</strong></u></p>
<p><u><strong>空间复杂度：O(1)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>,mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分搜索结束的标志一般就是left&gt;right。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间节点用(left+right)/2，不用(right-left)/2+left。</span></span><br><span class="line">            <span class="comment">//为mid赋值的表达式最好放在每次循环的最开始，这样更美观协调。</span></span><br><span class="line">            mid = ( left + right ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//这里一定要是right=mid-1,而不是right=mid。</span></span><br><span class="line">                    <span class="comment">//因为我们已经判断过了mid位置的整数不是目标值，所以可以跳过这个位置的数，将其排除出往后判断的范围。</span></span><br><span class="line">                    <span class="comment">//而且很重要的一点是：right=mid-1使判断边界缩进一点，才有可能通过条件left&gt;right是循环结束，否则循环永远也不会结束。</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//同理此处必须是left=mid+1,而不是left=mid。</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><p><strong><u>非常重要：代码块中的注释标注了使用二分搜索法要注意的细节，这是本题的重中之重。</u></strong></p>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
<p>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(Arrays.toString(s.searchRange(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>&#125;, <span class="number">7</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：二分搜索-1"><a href="#方法一：二分搜索-1" class="headerlink" title="方法一：二分搜索"></a>方法一：二分搜索</h3><p><strong><u>本题最重要、最关键的思路：分成两步分别去思考，先二分查找左边界位置，再二分查找右边界位置。</u></strong></p>
<p><u><strong>时间复杂度：O(logn)</strong></u></p>
<p><u><strong>空间复杂度：O(1)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分查找左边界。</span></span><br><span class="line">        <span class="comment">//因为我们最后想要的就是left会指到target位置，所以此处终止循环的条件就是left==right。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意此处用right=mid，而不用right=mid-1，因为条件中nums[mid]可能就是目标值，不能把它排除出去了。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证数组中是否真的存在目标值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] != target) <span class="keyword">return</span> answer;</span><br><span class="line">        answer[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分查找有边界</span></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意此处如果是(left + right)/2则有可能进入无限循环，因为(left + right)/2是向下取整的，</span></span><br><span class="line">            <span class="comment">//当left=right-1时，可能导致left一直等于mid。</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer[<span class="number">1</span>] = left;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><p><strong><u>还是代码段中的注释很重要，注意使用二分法时的等号细节。</u></strong></p>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>其中candidates 中的数字可以无限制重复被选取。</p>
<p>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<p>示例 1：<br>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[<br>  [7],<br>  [2,2,3]<br>]</p>
<p>示例 2：<br>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum</a></p>
<hr>
<h3 id="方法一：递归回溯法"><a href="#方法一：递归回溯法" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><u><strong>思路：看到这种要生成多种可能的组合的题目，首先就要考虑一下递归法和递归回溯法。</strong></u></p>
<p><u><strong>递归回溯法和递归法还是有一些区别的，回溯法是在递归法的基础之上增加回溯，使得可以重复使用同一个引用对象。</strong></u></p>
<p><strong>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。</strong></p>
<p><strong>空间复杂度：O(target)。</strong>(复杂度给出的都是最坏情况)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        combination(candidates,target,<span class="number">0</span>,<span class="number">0</span>,answer,answers);</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now表示现在所加到队列中数的和，temp表示当前所指到的数的数组索引，answer表示当前在数组中的数，也是回溯法的关键重复引用对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span>[] c,<span class="keyword">int</span> target,<span class="keyword">int</span> now,<span class="keyword">int</span> temp,List&lt;Integer&gt; answer,List&lt;List&lt;Integer&gt;&gt; answers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == c.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (now == target) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：这里每次添加到最终结果answers中的列表元素一定要是重复引用对象answer的当前状态，所有一定要新建一个列表保存其当前状态，否则这个answer马上又会改变。</span></span><br><span class="line">            <span class="comment">//这里如果写成answers.add(answer)则会使最终结果answers中的元素全都是answer的最终状态。</span></span><br><span class="line">            answers.add(<span class="keyword">new</span> LinkedList&lt;&gt;(answer));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (now &lt; target) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不调用c[temp]作为一个加数，指针直接跳过该数的情况</span></span><br><span class="line">            combination(c, target, now, temp + <span class="number">1</span>, answer, answers);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用c[temp]作为一个加数，指针还停留在该数上的情况。</span></span><br><span class="line">            <span class="comment">//注意这里就考虑这两种情况就是把所有情况都囊括进来了，</span></span><br><span class="line">            <span class="comment">//把c[temp]作为一个加数同时指针跳过该数这种情况也已经包括进来了，实际上就是先执行下面这种情况再执行上面那种情况。</span></span><br><span class="line">            answer.add(c[temp]);</span><br><span class="line">            combination(c, target, now + c[temp], temp, answer, answers);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重点：这一句是回溯法的精髓，重复使用的引用对象在添加了一个元素，然后执行递归函数之后，一定要把加上去的元素去掉。</span></span><br><span class="line">            answer.remove(answer.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：<img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_42.%E6%8E%A5%E9%9B%A8%E6%B0%B4%5C1.png" alt><br>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p>示例 2：<br>输入：height = [4,2,0,3,2,5]<br>输出：9</p>
<p>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a></p>
<hr>
<h3 id="方法一：暴力法-2"><a href="#方法一：暴力法-2" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong><u>既然想不出巧妙的简便方法，打算用暴力法，那么就先思考最暴力的方法，思考最直接的方法。比如此处就思考每一个格子上方盛的水是多少，而不要再去考虑每一个倒三角小水坑怎么得到。每一个格子上方盛的水取决于该格子两边最高的格子中相对较低的那一个。</u></strong></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                left = Math.max(height[j],left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; height.length; j++) &#123;</span><br><span class="line">                right = Math.max(height[j],right);</span><br><span class="line">            &#125;</span><br><span class="line">            answer = answer + Math.min(left,right) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态编程"><a href="#方法二：动态编程" class="headerlink" title="方法二：动态编程"></a>方法二：动态编程</h3><p><strong><u>暴力法的简化，典型的空间换时间，把二重循环编程一重循环。思路就是遍历找出数组中每个数左边(包括该数自己)的最大值，再遍历找出数组中每个数右边的最大值。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> answer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//空间换时间，将每个数最左边和最右边的最大值都记录下来，方便随时调用</span></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：空间换时间的关键，利用了最大值的传递性一次遍历找出每个数左边最大的值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMax[i] = Math.max(height[i],leftMax[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMax[i] = Math.max(height[i],rightMax[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            answer = answer + Math.min(leftMax[i],rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：栈-1"><a href="#方法三：栈-1" class="headerlink" title="方法三：栈"></a>方法三：栈</h3><h3 id="方法四：双指针"><a href="#方法四：双指针" class="headerlink" title="方法四：双指针"></a>方法四：双指针</h3><p>后两种方法太难理解了，也太难想到了。</p>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:<br>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.permute(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：回溯法"><a href="#方法一：回溯法" class="headerlink" title="方法一：回溯法"></a>方法一：回溯法</h3><p><u><strong>时间复杂度：O(n*n!)，getPermute()的调用次数O(n!) 的，而对于getPermute()调用的每个叶结点（共n!个），我们需要将当前答案使用O(n)的时间复制到答案数组中，相乘得时间复杂度为O(n*n!)。</strong></u></p>
<p><u><strong>空间复杂度：O(n)，要为每一层递归分配栈空间，这里所需要的额外空间取决于递归的深度，最深递归n层。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; numList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            numList.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        getPermute(numList,n,answer,answers);</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPermute</span><span class="params">(List&lt;Integer&gt; numsList,<span class="keyword">int</span> n,List&lt;Integer&gt; answer,List&lt;List&lt;Integer&gt;&gt; answers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (answer.size() == n) &#123;</span><br><span class="line">            answers.add(<span class="keyword">new</span> LinkedList&lt;&gt;(answer));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numsList.remove(i);</span><br><span class="line">            answer.add(temp);</span><br><span class="line">            getPermute(numsList,n,answer,answers);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯。每次执行完一个递归之后，一定要在同层次的下一个递归函数执行之前将改变了的元素全部回溯成原来的状态。</span></span><br><span class="line">            numsList.add(i,temp);</span><br><span class="line">            answer.remove(answer.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。</p>
<p>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:<br>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/rotate-image" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-image</a></p>
<hr>
<h3 id="方法一：自己写的"><a href="#方法一：自己写的" class="headerlink" title="方法一：自己写的"></a>方法一：自己写的</h3><p><strong>旋转四个等腰三角形，注意一下边界，每个等腰三角形只包括一条等腰边，矩形中心不用考虑。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:<br>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/group-anagrams" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1 s = <span class="keyword">new</span> Solution1();</span><br><span class="line">        System.out.println(s.groupAnagrams(<span class="keyword">new</span> String[]&#123;<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法一：排序数组分类"><a href="#方法一：排序数组分类" class="headerlink" title="方法一：排序数组分类"></a>方法一：排序数组分类</h3><p><u><strong>思路：当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</strong></u></p>
<p><u><strong>重要：哈希表是一个很好的工具，力扣题中经常使用。在需要用一个标志代表一组具有某种共性的数据时就使用哈希表。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&gt; answer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Array工具为字符数组排序，该工具可以为任何可比较对象数组排序。</span></span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：注意这里一定要用String.valueOf(chars)才能将字符数组合并成字符串，而不能用chars.toString()。</span></span><br><span class="line">            <span class="comment">//使用toString()方法时一定要注意不同对象的该方法所代表的意义，比如此处的chars.toString()实际上是将chars引用变量所指向的内存地址转化成字符串。</span></span><br><span class="line">            String key = String.valueOf(chars);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!answer.containsKey(key)) &#123;</span><br><span class="line">                answer.put(key,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            answer.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：注意List的有参构造函数的参数类型是collection，使用有参构造函数时不能加上泛型&lt;&gt;,所以这里一定不能写成ArrayList&lt;&gt;(answer.values())。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(answer.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：按字符计数分类"><a href="#方法二：按字符计数分类" class="headerlink" title="方法二：按字符计数分类"></a>方法二：按字符计数分类</h3><p><u><strong>思路：计算出字符串中每个字符出现的次数，当且仅当它们的字符计数(每个字符的出现次数)相同时，两个字符串是字母异位词。</strong></u></p>
<p><u><strong>在Java中，我们的字符数量count的散列化表示将是一个用＃字符分隔的字符串。例如，abbccc将表示为<code>＃1＃2＃3＃0＃0＃0...＃0</code>，其中总共有26个条目。</strong></u></p>
<p><u><strong>该思路和方法同样可以扩展到计算数字字符或者大写字母字符的出现次数计算。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&gt; answer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先设置一个长度为26的整数数组用来保存每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Arrays.fill()方法可以为各种数组全部赋同一值</span></span><br><span class="line">            Arrays.fill(count,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                count[c - <span class="string">'a'</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建字符计数数组count的散列化表示</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">'#'</span>);</span><br><span class="line">                sb.append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            String key = sb.toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!answer.containsKey(key)) &#123;</span><br><span class="line">                answer.put(key,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            answer.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(answer.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a></p>
<hr>
<h3 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>思路：定义状态f[i]为以索引i位置数为尾端的所有连续子序列中，和最大的那个连续子序列的和。</u></strong></p>
<p><strong>(状态转移方程非常巧妙，比较难想，只能硬记这道题)</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们只需要找出动态规划状态数组中最大的状态值，这里因为f[i-1]与f[i]的传递相关性，不用创建f[i]数组即可达到目的。</span></span><br><span class="line">        <span class="comment">//数组第一个元素即为初始化状态边界。</span></span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//状态转移方程</span></span><br><span class="line">            pre = Math.max(pre + nums[i],nums[i]);</span><br><span class="line"></span><br><span class="line">            max = Math.max(pre,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a></p>
<hr>
<h3 id="方法一：递归回溯法-1"><a href="#方法一：递归回溯法-1" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><strong><u>思路：看到这种可以每一个步骤可以跳一步、两步、三步等不确定步数时，一下就想到了递归回溯法。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常重要：List&lt;&gt;这种类型的对象引用变量才可以作为回溯方法的一个参数，来标志回溯到终点是否满足要求。</span></span><br><span class="line"><span class="comment">//而且必须通过add这种方法增加一个新的数据来表示回溯到终点满足要求，而不能是通过改变变量指向的地址来表示。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        jump(nums,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> !ans.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> temp,List&lt;Boolean&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[temp] == <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums[temp]; i++) &#123;</span><br><span class="line">                    temp = temp + i;</span><br><span class="line">                    jump(nums,temp,ans);</span><br><span class="line">                    temp = temp - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常重要：</span></span><br><span class="line"><span class="comment">//以下是错误的递归回溯写法：int、boolean等类型的对象引用不能作为一个递归方法的输入参数，用来记录递归回溯是否到达终点并满足要求的标志。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">        jump(nums,<span class="number">0</span>,ans);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意此处虽然我们把ans当作了递归方法的输入参数，但是只是把数据false给进去了，递归方法中的同名基本数据类型对象引用变量ans是一个全新的局部变量。</span></span><br><span class="line">        <span class="comment">//最后返回的ans就是一直指向false数值的变量ans。</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> temp,<span class="keyword">boolean</span> ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[temp] == <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums[temp]; i++) &#123;</span><br><span class="line">                    temp = temp + i;</span><br><span class="line">                    jump(nums,temp,ans);</span><br><span class="line">                    temp = temp - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：贪心法"><a href="#方法二：贪心法" class="headerlink" title="方法二：贪心法"></a>方法二：贪心法</h3><p><u><strong>只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为x+nums[x]，这个值大于等于 y，即x+nums[x]≥y，那么位置 y 也可以到达。</strong></u></p>
<p><u><strong>换句话说，对于每一个可以到达的位置x，它使得x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</strong></u></p>
<p><u><strong>这样一来，我们依次遍历数组中的每一个位置，并实时维护最远可以到达的位置。对于当前遍历到的位置 x，如果它在最远可以到达的位置的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用x+nums[x] 更新最远可以到达的位置。</strong></u></p>
<p><u><strong>在遍历的过程中，如果最远可以到达的位置大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回True作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回False作为答案。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个能到达的最远位置一定要在每次循环的时候都判断是否更新，</span></span><br><span class="line">                <span class="comment">//因为有可能后面的位置能到达的最远距离反而不如前面的位置能到达的最远距离远。</span></span><br><span class="line">                rightmost = Math.max(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p> 示例 1:<br>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2:<br>输入: intervals = [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/merge-intervals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals</a></p>
<hr>
<h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p><u><strong>思路：一定要先将所有的区间按左端点的大小进行排序，这样才能保证可以合并的区间是连续的。</strong></u></p>
<p><u><strong>然后就好办了，依次判断每两个连续的区间是否需要合并。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：自定义外部比较器的用法实例。这个还比较常用，要记住写法。</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                intervals[i + <span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注意这种特殊情况：如果前一个区间完全包含后一个区间，则后一个区间完全被覆盖。</span></span><br><span class="line">                <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; intervals[i + <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                    intervals[i + <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List的toArray()方法的使用实例。用一个循环一个一个取出来也是一样的，只不过这种写法更方便快捷。</span></span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1:<br>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p>示例 2:<br>输入: m = 7, n = 3<br>输出: 28</p>
<p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p>
<hr>
<h3 id="方法一：递归回溯法-2"><a href="#方法一：递归回溯法-2" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><strong><u>可以是可以，但是十分浪费内存，效率很低，远不如动态规划。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path(m,n,<span class="number">1</span>,<span class="number">1</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == m &amp;&amp; y == n) &#123;</span><br><span class="line">            ans.add(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; m || y &gt; n) &#123;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            path(m,n,x+<span class="number">1</span>,y,ans);</span><br><span class="line">            path(m,n,x,y+<span class="number">1</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-1"><a href="#方法二：动态规划-1" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><strong><u>这种最后要求我们只是输出种数的问题，且每一层的种数与上一层的种数密切相关的情况，完全可以用动态规划来代替递归回溯。</u></strong></p>
<p><strong>时间复杂度：O(mn)</strong></p>
<p><strong>空间复杂度：O(mn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示终点为第i+1行、第j+1竖点时的最多种不同路线。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例 1：<br>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p>示例 2：<br>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p>
<p>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a></p>
<hr>
<h3 id="方法一：动态规划-2"><a href="#方法一：动态规划-2" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>在62.不同路径上的基础之上做出一些改进即可。</u></strong></p>
<p><strong>时间复杂度：O(mn)</strong></p>
<p><strong>空间复杂度：O(mn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = grid.length;</span><br><span class="line">        <span class="keyword">int</span> width = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示第i+1行第j+1列位置为终点的路径上最小数字总和。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[height][width];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; width; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[height - <span class="number">1</span>][width - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<p>示例 1：<br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>示例 2：<br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a></p>
<hr>
<h3 id="方法一：动态规划-3"><a href="#方法一：动态规划-3" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>时间复杂度：O(n)</strong></u></p>
<p><u><strong>空间复杂度：O(n)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i]表示爬到第i+1个阶梯的不同爬法种数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n -<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-2"><a href="#方法二：动态规划-2" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><u><strong>思路：其实状态转移方程每次只需要使用前两个状态，之后再也不用使用到前面的状态。那么完全可以降低动态规划的空间复杂度。</strong></u></p>
<p><u><strong>时间复杂度：O(n)</strong></u></p>
<p><u><strong>空间复杂度：O(1)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp + q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：<br>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<p>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a></p>
<hr>
<h3 id="方法一：动态规划-4"><a href="#方法一：动态规划-4" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><blockquote>
<p>这真的想不到了，只能硬背思路了。</p>
</blockquote>
<p><strong>我们可以对任意一个单词进行三种操作：</strong></p>
<ul>
<li><strong>插入一个字符；</strong></li>
<li><strong>删除一个字符；</strong></li>
<li><strong>替换一个字符。</strong></li>
</ul>
<p><strong>题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。</strong></p>
<p><strong>但我们可以发现，如果我们有单词 A 和单词 B：</strong></p>
<ul>
<li><strong>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</strong></li>
<li><strong>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</strong></li>
<li><strong>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</strong></li>
</ul>
<p><strong>这样以来，本质不同的操作实际上只有三种：</strong></p>
<ul>
<li><strong>在单词 A 中插入一个字符；</strong></li>
<li><strong>在单词 B 中插入一个字符；</strong></li>
<li><strong>修改单词 A 的一个字符。</strong></li>
</ul>
<p><strong>这样一来，我们就可以把原问题转化为规模较小的子问题。我们用 A = horse，B = ros 作为例子，来看一看是如何把这个问题转化为规模较小的若干子问题的。</strong></p>
<ul>
<li><strong>在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；</strong></li>
<li><strong>在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；</strong></li>
<li><strong>修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。</strong></li>
</ul>
<p><strong>那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。</strong></p>
<p><strong>注意：为什么我们总是在单词 A 和 B 的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词 cat，我们希望在 c 和 a 之间添加字符 d 并且将字符 t 修改为字符 b，那么这两个操作无论为什么顺序，都会得到最终的结果 cdab。</strong></p>
<p><strong>你可能觉得 horse 到 ro 这个问题也很难解决。但是没关系，我们可以继续用上面的方法拆分这个问题，对于这个问题拆分出来的所有子问题，我们也可以继续拆分，直到：</strong></p>
<ul>
<li><strong>字符串 A 为空，如从 转换到 ro，显然编辑距离为字符串 B 的长度，这里是 2；</strong></li>
<li><strong>字符串 B 为空，如从 horse 转换到 ，显然编辑距离为字符串 A 的长度，这里是 5。</strong></li>
</ul>
<p><u><strong>因此，我们就可以使用动态规划来解决这个问题了。我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。</strong></u></p>
<p><u><strong>如上所述，当我们获得 D[i][j-1]，D[i-1][j] 和 D[i-1][j-1] 的值之后就可以计算出 D[i][j]。</strong></u></p>
<ul>
<li><u><strong>D[i][j-1] 为 A 的前 i 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i][j-1] + 1；</strong></u></li>
<li><u><strong>D[i-1][j] 为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题。即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i-1][j] + 1；</strong></u></li>
<li><u><strong>D[i-1][j-1] 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么 D[i][j] 最小可以为 D[i-1][j-1] + 1。特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，D[i][j] 最小可以为 D[i-1][j-1]。</strong></u></li>
</ul>
<p><u><strong>那么我们可以写出如下的状态转移方程：</strong></u></p>
<ul>
<li><p><u><strong>若 A 和 B 的最后一个字母相同：</strong></u></p>
<p><u><strong>D[i][j]=min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)​</strong></u></p>
</li>
</ul>
<ul>
<li><p><u><strong>若 A 和 B 的最后一个字母不同：</strong></u></p>
<p><u><strong>D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])</strong></u></p>
</li>
</ul>
<p><u><strong>对于边界情况，一个空串和一个非空串的编辑距离为 D[i][0] = i 和 D[0][j] = j，D[i][0] 相当于对 word1 执行 i 次删除操作，D[0][j] 相当于对 word1执行 j 次插入操作。</strong></u></p>
<p><u><strong>综上我们得到了算法的全部流程。</strong></u></p>
<p><strong>时间复杂度：O(mn)</strong></p>
<p><strong>空间复杂度：O(mn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示word1的前i个字符与word2的前j个字符的编辑距离</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i - <span class="number">1</span>][j] + <span class="number">1</span>),dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]),dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><u>和<a href="https://littleforestjia.github.io/2020/10/20/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/" target="_blank" rel="noopener">10.正则表达式匹配</a>一样，这种涉及到字符串比较，包括字符顺序比较的题目，一般都是用动态规划。而像<a href="https://littleforestjia.github.io/2020/11/05/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_49.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/" target="_blank" rel="noopener">49.字母异位词分组</a>这种不涉及顺序比较的字符串比较，则可以直接枚举出每个字符的出现次数来比较。</u></strong></li>
</ul>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>进阶：<br>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<p>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p>
<p>示例 2：<br>输入：nums = [2,0,1]<br>输出：[0,1,2]</p>
<p>示例 3：<br>输入：nums = [0]<br>输出：[0]</p>
<p>示例 4：<br>输入：nums = [1]<br>输出：[1]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a></p>
<hr>
<h3 id="方法一：暴力法-3"><a href="#方法一：暴力法-3" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong>思路：一次遍历计算出每种颜色的个数，二次遍历给数组重新赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> red = <span class="number">0</span>,white = <span class="number">0</span>,blue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                red++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                white++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                blue++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; red; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = red; i &lt; red + white; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = red + white; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双指针-1"><a href="#方法二：双指针-1" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p><strong>思路：分别设置指针表示头部和尾部，遍历数组，当数据为0时与头部位置交换，并将头部位置后移一位；当数据为2时与尾部位置交换，并将尾部位置前移一位，同时重新遍历一次该位置。也就是说要保证头部位置以前全是0，尾部位置以后全是2。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>,end = nums.length - <span class="number">1</span>,temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= end;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                temp = nums[head];</span><br><span class="line">                nums[head] = <span class="number">0</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                head++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                temp = nums[end];</span><br><span class="line">                nums[end] = <span class="number">2</span>;</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                end--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><strong><u>双指针可以用于减少遍历次数。</u></strong></p>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：本题要考虑t中相同字符的个数；如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：<br>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p>
<p>示例 2：<br>输入：s = “a”, t = “a”<br>输出：”a”</p>
<p>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring</a></p>
<hr>
<h3 id="方法一：滑动窗口法"><a href="#方法一：滑动窗口法" class="headerlink" title="方法一：滑动窗口法"></a>方法一：滑动窗口法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>设置左右两个指针：</strong></p>
<ul>
<li><u><strong>右指针一直后移，直到两指针之间涵盖t中所有字符；</strong></u></li>
<li><u><strong>这时再后移左指针，直到两指针之间不再涵盖t中所有字符；</strong></u></li>
<li><u><strong>这时再后移右指针，如此循环，直到找出两指针之间涵盖t中所有字符的情况中两指针距离最小的情况。</strong></u></li>
</ul>
<p><strong>以上想到的这个思路是正确的，就是编程实现起来不太容易，实现形式也可以有很多种，自己要记住一种能自己写出来。</strong></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><strong>以上思路更准确的步骤描述：</strong></p>
<ol>
<li><strong>不断增加right使滑动窗口增大，直到窗口包含了t的所有元素；</strong></li>
<li><strong>不断增加left使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值；</strong></li>
<li><strong><u>让left再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到right超出了字符串S范围。(这一步很重要且很容易忽略)</u></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：ascii码表即为字符与数字的对照表，表中一共128个字符，分别对应数字0-127。</span></span><br><span class="line">        <span class="comment">//用容量为128的整数数组表示两指针之间想要涵盖t中所有字符时，所需要的每个字符的个数。</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算出字符串t中所包含的每个字符的个数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：java中字符串char和整数int在默认情况下可以自动通过ascii码表转换数据类型。</span></span><br><span class="line">            <span class="comment">//比如t.charAt(i) - 1;语句得到的结果为一个int类型数据。</span></span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//left为左指针，right为右指针，count用于记录还有多少个t中字符没有被左右指针涵盖，</span></span><br><span class="line">        <span class="comment">//size用于记录涵盖所有字符时左右指针之间的距离，start用于记录涵盖所有字符时左指针所在位置索引。</span></span><br><span class="line">        <span class="comment">//重要：因为size应该是一个一直通过比较然后获得更小值的变量，所以初始值设置为整型数的最大值。</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,count = t.length(),size = Integer.MAX_VALUE,start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果右指针所指字符是t中存在字符，则将count减一。</span></span><br><span class="line">            <span class="keyword">if</span> (need[s.charAt(right)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            need[s.charAt(right)]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//need[s.charAt(left)] &lt; 0就表示left所指字符是比t中所多出的字符。</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need[s.charAt(left)]++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right + <span class="number">1</span> - left &lt; size) &#123;</span><br><span class="line">                    size = right + <span class="number">1</span> - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找到以当前右指针为结尾的最小子串后，继续将左指针后移一位，这样才能是右指针开始正常向后移动。</span></span><br><span class="line">                need[s.charAt(left)]++;</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(start,start + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
<p>示例:<br>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets</a></p>
<hr>
<h3 id="方法一：递归回溯"><a href="#方法一：递归回溯" class="headerlink" title="方法一：递归回溯"></a>方法一：递归回溯</h3><p><u><strong>非常重要：这个递归回溯的特点就是：不考虑顺序。</strong></u></p>
<p><u><strong>之前的递归回溯，一般都是要考虑每个元素的顺序，注意这个不考虑顺序的递归回溯是如何避免选取到元素相同、顺序不同的列表元素的。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：在声明以列表为元素的列表时，一定要声明完整。List&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        sets(nums,current,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sets</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;Integer&gt; current,<span class="keyword">int</span> temp,List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = temp; i &lt; nums.length; i++) &#123;</span><br><span class="line">            current.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//必须要新建一个与current数据一样的列表，不能将current作为一个元素放入ans中，否则后面current改变，ans的已有元素也会跟着改变。</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(current));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：因为不考虑列表中整数的顺序，所以必须排除元素相同、顺序不同的情况。思路就是通过将i+1作为输入参数使每个整数只能与其后面的整数搭配组成数组。</span></span><br><span class="line">            sets(nums,current,i + <span class="number">1</span>,ans);</span><br><span class="line"></span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 </p>
<p>示例:</p>
<blockquote>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/word-search" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search</a></p>
<hr>
<h3 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h3><p><u><strong>这道题本质上其实也是递归回溯法，但是不同于之前一直用的递归函数定义方法，之前一直定义递归函数方法返回值类型为void，这里要定义递归函数返回值类型为每一层递归的判断结果boolean。</strong></u></p>
<p><u><strong>这里深度优先搜索体现在先不管结果如何，一直往下递归，到递归终止条件再返回，只有每一层的返回值都为true，才会使最外层递归方法的返回值也为true。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length,n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个布尔值二维表，用来表示board表中对应位置是否被访问过。</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先定位一个起始点，就是二维表中任意一个与word首字符相等的点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//然后通过递归回溯法查看以该点为起点是否能找到完整的word字符串，一旦找到直接返回true，没找到就继续循环。</span></span><br><span class="line">                <span class="keyword">if</span> (charExist(board,i,j,visited,word,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">charExist</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] visited,String word,<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果指定二维字符表中位置的字符与指定word中字符不相等，则直接返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word.charAt(temp)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若相等，且该word中字符已经是字符串中最后一个字符了，则直接返回true。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == word.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//那么下面的情况就是指定二维字符表中的字符与指定word中字符相等，且不是字符串中最后一个字符时所要执行的操作了。</span></span><br><span class="line">        <span class="comment">//先把访问表修改，表示该点已被访问过。</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别考虑向上下左右四个方向递归的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">            <span class="comment">//如果下层满足要求则直接返回true。</span></span><br><span class="line">            <span class="keyword">if</span> (charExist(board,i - <span class="number">1</span>,j,visited,word,temp + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; board.length &amp;&amp; !visited[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charExist(board,i + <span class="number">1</span>,j,visited,word,temp + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charExist(board,i,j - <span class="number">1</span>,visited,word,temp + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;board[<span class="number">0</span>].length &amp;&amp; !visited[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charExist(board,i,j + <span class="number">1</span>,visited,word,temp + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问表要回溯。</span></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%5C1.png" alt></p>
<blockquote>
<p>示例:<br>输入: [2,1,5,6,2,3]<br>输出: 10</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></p>
<hr>
<h3 id="方法一：暴力法-4"><a href="#方法一：暴力法-4" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong><u>找出每个柱形所对应的以此柱为最高柱的矩形，思路就是找出每个柱形两边第一个比该柱低的柱形。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; heights.length &amp;&amp; heights[right] &gt;= heights[i]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,(right - left - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><p><u><strong>空间换时间，将二重循环转化成一重循环。</strong></u></p>
<p><u><strong>思路：维护一个单调栈，通过单调栈可以一次遍历找出每个柱行左边第一个小于他的柱行的位置，再通过一次遍历找出右边第一个小于他的柱行的位置。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个单调栈，每次比较栈顶元素与被遍历元素，栈顶元素比该被遍历元素大就丢出去，比它小就作为离它最近的比它小的柱行的位置。</span></span><br><span class="line">        Stack&lt;Integer&gt; oneSide = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出每个柱行左边离它最近的比它小的柱行的位置。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!oneSide.isEmpty() &amp;&amp; heights[oneSide.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                oneSide.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oneSide.isEmpty()) &#123;</span><br><span class="line">                left[i] = -<span class="number">1</span>;</span><br><span class="line">                oneSide.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = oneSide.peek();</span><br><span class="line">                oneSide.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oneSide.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出每个柱行右边离它最近的比它小的柱行的位置。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!oneSide.isEmpty() &amp;&amp; heights[oneSide.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                oneSide.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oneSide.isEmpty()) &#123;</span><br><span class="line">                right[i] = n;</span><br><span class="line">                oneSide.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = oneSide.peek();</span><br><span class="line">                oneSide.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans,(right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><strong><u>这道题其实和<a href="https://littleforestjia.github.io/2020/11/03/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/" target="_blank" rel="noopener">42.接雨水</a>很像，方法一暴力法都是枚举每一个柱形作为高，方法二都是在方法一暴力法的基础上空间换时间。</u></strong></p>
<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85.最大矩形"></a>85.最大矩形</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%5C1.png" alt></p>
<blockquote>
<p>示例 1：<br>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/maximal-rectangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle</a></p>
<hr>
<h3 id="方法一：柱状图-枚举高暴力法-动态规划"><a href="#方法一：柱状图-枚举高暴力法-动态规划" class="headerlink" title="方法一：柱状图_枚举高暴力法+动态规划"></a>方法一：柱状图_枚举高暴力法+动态规划</h3><p><u><strong>思路：对每一行建立柱状图，也就是分别研究矩阵的每一行作为矩形的底时所能求到的最大矩形，所以每次对一行建立柱状图时，只需考虑该行及其上方的格子。</strong></u></p>
<p><u><strong>同时用动态规划求出每个字符为1的格子与其上方字符为1的格子共同构成的最大高度。</strong></u></p>
<p><strong>时间复杂度：O(n^2*m)</strong></p>
<p><strong>空间复杂度：O(n*m)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止matrix[0]不存在造成下一句错误。</span></span><br><span class="line">        <span class="comment">//matrix[0][0]不存在倒是不会出错，所以涉及输入为矩阵的题目，最好还是加上这一句。</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：表示每个格子上的高度，也就是每个格子与其上方也为1的格子连起来的高度。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//初始化</span></span><br><span class="line">                    dp[i][j] = matrix[i][j] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//状态转移方程</span></span><br><span class="line">                    dp[i][j] = matrix[i][j] == <span class="string">'1'</span> ? dp[i - <span class="number">1</span>][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到每一行的柱状图之后，马上求该行对应柱状图中的最大矩形，并比较得出所有行对应柱状图中的最大矩形。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; dp[i][left] &gt;= dp[i][j]) &#123;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> right = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n &amp;&amp; dp[i][right] &gt;= dp[i][j]) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = Math.max(maxArea,(right - left - <span class="number">1</span>) * dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：柱状图-枚举高单调栈优化-动态规划优化"><a href="#方法二：柱状图-枚举高单调栈优化-动态规划优化" class="headerlink" title="方法二：柱状图_枚举高单调栈优化+动态规划优化"></a>方法二：柱状图_枚举高单调栈优化+动态规划优化</h3><p><strong><u>思路：在使用单调栈优化求解柱状图最大矩形的基础上。另外其实动态规划也可以优化，因为每求一行的状态时，只需用到上一行的状态，用完就不再需要，所以动态规划状态可以从二维优化为一维。所以其实这种方法比第一种在时间和空间上复杂度都减小了。</u></strong></p>
<p><strong>时间复杂度：O(n*m)</strong></p>
<p><strong>空间复杂度：O(m)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存放每个位置左边最近更低高度位置</span></span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//用于存放每个位置左边最近更低高度位置</span></span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = matrix[i][j] == <span class="string">'1'</span> ? dp[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用单调栈求该行对应柱状图中的最大矩形，并比较得出所有行对应柱状图中的最大矩形。</span></span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!temp.isEmpty() &amp;&amp; dp[temp.peek()] &gt;= dp[j]) &#123;</span><br><span class="line">                    temp.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.isEmpty()) &#123;</span><br><span class="line">                    left[j] = -<span class="number">1</span>;</span><br><span class="line">                    temp.push(j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    left[j] = temp.peek();</span><br><span class="line">                    temp.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!temp.isEmpty() &amp;&amp; dp[temp.peek()] &gt;= dp[j]) &#123;</span><br><span class="line">                    temp.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.isEmpty()) &#123;</span><br><span class="line">                    right[j] = n;</span><br><span class="line">                    temp.push(j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right[j] = temp.peek();</span><br><span class="line">                    temp.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea,(right[j] - left[j] - <span class="number">1</span>) * dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><strong><u>其实本题就是一个<a href="https://littleforestjia.github.io/2020/11/24/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/" target="_blank" rel="noopener">84.柱状图中最大的矩形</a>的二维展开，在84题的每种方法上都可以扩展衍生出该题对应的方法，比如84题主要有三种方法：枚举宽暴力法、枚举高暴力法、枚举高单调栈优化，本题中我们选择后两种方法来进行二维扩展。</u></strong></p>
<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树的根节点root，返回它的中序遍历。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>
<hr>
<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(ans,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(List&lt;Integer&gt; ans,TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重要：必须先判断node==null，才能在判断node.left==null，因为当node==null正确时，node.left这个语句错误。</span></span><br><span class="line">        <span class="comment">//node==null为递归终止条件。</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traversal(ans,node.left);</span><br><span class="line">        ans.add(node.val);</span><br><span class="line">        traversal(ans,node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：栈-1"><a href="#方法二：栈-1" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p><u><strong>二叉树的前中后序遍历除了递归方法，都可以用栈来进行迭代遍历出来。</strong></u></p>
<p><u><strong>中序遍历思路：当每个节点有左子节点时，先不遍历该节点，将该节点放入栈中，直到找到没有左子节点的节点，再开始遍历节点，然后查看该节点有无右子节点，如有则重复上述步骤。</strong></u></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//root还不是null或者栈中还有节点，则说明节点还没有遍历完毕。</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<blockquote>
<p>示例:<br>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      <br>     3     2     1      1   3      2<br>    /     /       \                 <br>   2     1         2                 3</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees</a></p>
<hr>
<h3 id="方法一：动态规划-5"><a href="#方法一：动态规划-5" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><h4 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h4><p><u><strong>G(n)：长度为 n 的序列能构成的不同二叉搜索树的个数。</strong></u></p>
<p><u><strong>F(i, n)：以i为根、序列长度为 n 的不同二叉搜索树个数(1≤i≤n)。</strong></u></p>
<h4 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h4><p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C1.png" alt></p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C2.png" alt></p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5C3.png" alt></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态：dp[n]表示n个不同的整数所能组成的不同二叉搜索树种类。</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化。无整数时，也是一种，那就是根节点为空的二叉搜索树。</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//状态转移方程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] = dp[i] + dp[j - <span class="number">1</span>]*dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a></p>
<hr>
<h3 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h3><p><strong><u>思路：二叉搜索树中序遍历结果为单调递增或者单调递减。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JAVA中浮点数float、double的最小值MIM_VALUE不是一个负数，而是能取到的最小正数。</span></span><br><span class="line">        <span class="keyword">double</span> temp = -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中序遍历时要对被遍历节点进行的操作：判断该节点数值是否大于上一个节点的数值。</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= root.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = root.val;</span><br><span class="line"></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p>​    1</p>
<p>   / <br>  2   2<br> / \ / <br>3  4 4  3</p>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>​    1</p>
<p>   / <br>  2   2<br>   \   <br>   3    3</p>
<p>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p>
<hr>
<h3 id="方法一：中序遍历-1"><a href="#方法一：中序遍历-1" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h3><p><strong>思路：对称二叉树分别按左中右和右中左的顺序进行中序遍历的结果应该一样。</strong></p>
<p><strong><u>重要：这种方法错了，因为中序遍历结果不能唯一确定树的形状，不同形状的树可能具有相同的中序遍历结果。</u></strong></p>
<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p><strong><u>思路：给定两个一开始都指向根节点的指针，使两指针始终延相反方向前进，两指针指向的值一直相等即对称。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equal(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(TreeNode left,TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> &amp;&amp; left.val == right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span>  equal(left.left,right.right) &amp;&amp; equal(left.right,right.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><u>重温了一下前中后序遍历的迭代方法，感觉还是得硬记啊，要自己直接想出来还是有点难。</u></strong></li>
<li><strong><u>本题除了递归，一样可以使用迭代+栈的方法，二叉树相关题目的很多递归解法都可以转换成迭代+栈的解法。</u></strong></li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<blockquote>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],<br>  3<br> / <br>9  20<br>  /  <br>  15   7<br>返回其层次遍历结果：<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a></p>
<hr>
<h3 id="方法一：队列-广度优先搜索"><a href="#方法一：队列-广度优先搜索" class="headerlink" title="方法一：队列(广度优先搜索)"></a>方法一：队列(广度优先搜索)</h3><p><strong>思路：就是数据结构课程中讲解的使用队列对二叉树进行层序遍历的方法，只不过本题中要添加一些步骤，使得能够识别出每个节点所在的层数。</strong></p>
<p><strong><u>每次把一整层的节点数量计算出来，然后遍历这层的每个节点同时将该节点的子节点放入队列中，当遍历完该层节点时，队列中刚好就全是下一层的所有节点，这样又可以计算出下一层的节点数量。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑root为空的特殊情况。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中常用LinkedList实现Deque。</span></span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算每层的节点数量</span></span><br><span class="line">            <span class="keyword">int</span> levelLength = deque.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                root = deque.poll();</span><br><span class="line">                answer.add(root.val);</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) deque.offer(root.left);</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) deque.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p>
<hr>
<h3 id="方法一：递归-1"><a href="#方法一：递归-1" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong><u>二叉树这里好多题目都可以用递归来做，所以遇到二叉树的题目都先想想递归。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(height)，其中height表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。<u>也就是说，如果每层递归函数的空间复杂度为n，总空间复杂度即为n*递归层数。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。<br>注意:<br>你可以假设树中没有重复的元素。</p>
<blockquote>
<p>例如，给出<br>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<hr>
<h3 id="方法一：递归-2"><a href="#方法一：递归-2" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>思路：就是数据结构课程中的重构思路。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出根节点数值在中序遍历数组中的位置，其左边数值为左子树数值，右边数值为右子树数值。</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[<span class="number">0</span>]) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出在左子树中的所有节点数值</span></span><br><span class="line">        <span class="keyword">int</span>[] leftPre = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">        <span class="keyword">int</span>[] leftIn = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootIndex; i++) &#123;</span><br><span class="line">            leftPre[i] = preorder[i + <span class="number">1</span>];</span><br><span class="line">            leftIn[i] = inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出在右子树中的所有节点数值</span></span><br><span class="line">        <span class="keyword">int</span>[] rightPre = <span class="keyword">new</span> <span class="keyword">int</span>[n - rootIndex - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightIn = <span class="keyword">new</span> <span class="keyword">int</span>[n - rootIndex - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - rootIndex - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            rightPre[i] = preorder[rootIndex + <span class="number">1</span> + i];</span><br><span class="line">            rightIn[i] = inorder[rootIndex + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归得到左子节点和右子节点</span></span><br><span class="line">        root.left = buildTree(leftPre,leftIn);</span><br><span class="line">        root.right = buildTree(rightPre,rightIn);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树，原地将它展开为一个单二叉树。</p>
<blockquote>
<p>例如，给定二叉树</p>
<p>   1<br>   / <br>  2   5<br> / \   <br>3   4   6<br>将其展开为：</p>
<p>1<br> <br>  2<br>   <br>    3<br>     <br>      4<br>       <br>        5<br>         <br>          6</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list</a></p>
<hr>
<h3 id="方法一：前序遍历"><a href="#方法一：前序遍历" class="headerlink" title="方法一：前序遍历"></a>方法一：前序遍历</h3><p><strong><u>重要：原地创建的意思就是不能new新的节点，只能在原来的节点的基础之上修改节点子链接。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代法前序遍历</span></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            nodeList.add(root);</span><br><span class="line">            <span class="comment">//根据栈的性质可知，越先入栈的节点，越后被访问。</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据得到的前序遍历数据表，递归创建新二叉树。</span></span><br><span class="line">        root = newTree(nodeList,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">newTree</span><span class="params">(List&lt;TreeNode&gt; nodeList,<span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == nodeList.size()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = nodeList.get(temp);</span><br><span class="line">        node.right = newTree(nodeList,temp + <span class="number">1</span>);</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：寻找前驱节点"><a href="#方法二：寻找前驱节点" class="headerlink" title="方法二：寻找前驱节点"></a>方法二：寻找前驱节点</h3><p><u><strong>思路：找到左子树的最右最下的节点(也就是前序遍历或中序遍历最后访问的节点)，作为右子树的父节点。</strong></u></p>
<p><u><strong>也就是说分析每个节点A，找到该节点的前驱节点B，把节点A的右子树切下来，将该右子树接到前驱节点B的右子节点，然后再把节点A左子树切下来放到节点A的右边。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为本题为无返回值原地创建，所以root变量相当于要提交的答案，此处我们不将root作为变化指针，创建一个新变量作为指针。</span></span><br><span class="line">        TreeNode curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//寻找该节点的前驱节点</span></span><br><span class="line">                TreeNode preNode = curr.left;</span><br><span class="line">                <span class="keyword">while</span> (preNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    preNode = preNode.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将右子树移植到前驱节点的右子节点位置</span></span><br><span class="line">                preNode.right = curr.right;</span><br><span class="line">                curr.right = curr.left;</span><br><span class="line">                curr.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p>
<hr>
<h3 id="方法一：动态规划-6"><a href="#方法一：动态规划-6" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp表示在第i卖出所能赚到的最多的钱。</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp = Math.max(dp + prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            max = Math.max(max,dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122.买卖股票的最佳时机2"></a>122.买卖股票的最佳时机2</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
<hr>
<h3 id="方法一：动态规划-7"><a href="#方法一：动态规划-7" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：dp[0][i]表示第i天结束时用户持有股票，这时用户的最大收益；</span></span><br><span class="line">        <span class="comment">//dp[1][i]表示第i天结束时用户没有持有股票，这时用户的最大收益。</span></span><br><span class="line">        <span class="keyword">int</span> dp0 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp0 = Math.max(dp0,dp1 - prices[i]);</span><br><span class="line">            dp1 = Math.max(dp0 + prices[i],dp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123.买卖股票的最佳时机3"></a>123.买卖股票的最佳时机3</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<blockquote>
<p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：prices = [1]<br>输出：0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p>
<hr>
<h3 id="方法一：动态规划-8"><a href="#方法一：动态规划-8" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>巧思题，要硬记。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：buy1表示第i天是持有第一次买入的一天时的最大收益，sell1表示第i天是已经卖出第一次交易、还未持有第二次买入时的最大收益，</span></span><br><span class="line">        <span class="comment">//buy2表示第i天是持有第二次买入的一天时的最大收益，sell2表示第i天是已经卖出第二次交易时的最大收益。</span></span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>],sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>],sell2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy1 = Math.max(buy1,-prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1,prices[i] + buy1);</span><br><span class="line">            buy2 = Math.max(buy2,sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2,prices[i] + buy2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.二叉树中的最大路径和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：[1,2,3]</p>
<p>   1<br>  / <br> 2   3</p>
<p>输出：6</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：[-10,9,20,null,null,15,7]</p>
<p>   -10<br>   / <br>  9  20<br>      /  <br>    15   7</p>
<p>输出：42</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a></p>
<hr>
<h3 id="方法一：递归-3"><a href="#方法一：递归-3" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><u><strong>重要：一定要理解，在二叉树中的一条路径一定是先上升然后下降的，或者只有上升或只有下降。不可能有两个或以上的方向变化。</strong></u></p>
<p><u><strong>所以任何一条路径一定是一个根节点加上一个左单度左子树和一个单度右子树。（单度子树就是指所有节点的度都为1或0的子树）</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非常重要：注意这个变量一定要声明为全局变量，这样在递归方法getMax()中修改该变量时，才能真的改变该变量。</span></span><br><span class="line">    <span class="comment">//如果在maxPathSum()中声明该变量为局部变量，然后在getMax()方法中想通过int ans输入该局部变量时系统根本不会认出它，</span></span><br><span class="line">    <span class="comment">//而是会重新开辟一个内存空间给int。链表等非基本数据类型倒是可以声明为一个方法的局部变量，然后在另一个方法中改变该变量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法：获取以输入节点为起点再加上它的一部分子孙所组成的最大路径和（其实就是获取一个路径和最大的单度子树）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMax = Math.max(getMax(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightMax = Math.max(getMax(root.right),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归函数内除了求解并返回目的值，同样可以做一些其他的事，比如此处更新最大路径和。</span></span><br><span class="line">        <span class="comment">//其实就是枚举每个节点作为路径根节点时的最大路径和，比较出最大的最大路径和。</span></span><br><span class="line">        ans = Math.max(ans,root.val + leftMax + rightMax);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？ </p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence</a></p>
<hr>
<h3 id="方法一：排序-动态规划"><a href="#方法一：排序-动态规划" class="headerlink" title="方法一：排序+动态规划"></a>方法一：排序+动态规划</h3><p><strong>注意：重复元素不重复增加最长连续序列的长度，但是也不中断最长连续序列长度的增加。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java工具箱中自带的该方法时间复杂度为O(nlogn)，空间复杂度为O(n)。</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：表示以数组中第i个数为结尾的最长连续序列的长度</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//存在重复元素，不增加长度，也不将长度归1，还可以继续增加下去。</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：HashSet"><a href="#方法二：HashSet" class="headerlink" title="方法二：HashSet"></a>方法二：HashSet</h3><p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Set为不含重复元素的集合，java中常用HashSet来实现。</span></span><br><span class="line">        Set&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            numbers.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="comment">//HashSet.contains()方法的时间复杂度为O(1)。</span></span><br><span class="line">            <span class="keyword">if</span> (!numbers.contains(num - <span class="number">1</span>)) &#123;<span class="comment">//表示该元素为一个连续序列的起点，而不是中间一个点。</span></span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (numbers.contains(num + length)) &#123;</span><br><span class="line">                    length++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans,length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [2,2,1]<br>输出: 1</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a></p>
<hr>
<h3 id="方法一：HashSet"><a href="#方法一：HashSet" class="headerlink" title="方法一：HashSet"></a>方法一：HashSet</h3><p><strong><u>常见时间复杂度有：常数阶O(1)，对数阶O(logn)，线性阶O(n)，线性对数阶O(nlogn)，平方阶O(n^2)，立方阶O(n^3)</u></strong></p>
<p><strong>本题所要求的 线性时间复杂度，即要求时间复杂度为O(n)。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap是用数组加链表来实现的，containsKey方法的复杂度为O(1)，containsValue方法的复杂度为O(n)。</span></span><br><span class="line">        HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers.contains(nums[i])) &#123;</span><br><span class="line">                numbers.remove(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                numbers.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers.contains(nums[i])) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h3><p><strong>位运算中的异或运算满足：</strong></p>
<ol>
<li><strong>任何数与0异或结果都为自身，</strong></li>
<li><strong>任何数与自身异或结果都为0，</strong></li>
<li><strong>异或运算符合交换律和结合律。</strong></li>
</ol>
<p><strong><u>根据以上条件将输入数组中所有整数全部异或，则最终结果应为只出现一次的那个整数。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//位运算中的异或运算符号：^</span></span><br><span class="line">            ans = ans ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>Java提供的位运算符有：左移<code>&lt;&lt;</code>、右移<code>&gt;&gt;</code> 、无符号右移<code>&gt;&gt;&gt;</code>、位与<code>&amp;</code> 、位或<code>|</code>、位非<code>~</code>、位异或<code>^</code>，除了位非<code>~</code>是一元操作符外，其它的都是二元操作符。</strong></p>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/word-break" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break</a></p>
<hr>
<h3 id="方法一：递归回溯法-3"><a href="#方法一：递归回溯法-3" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><u><strong>思路：尝试找出与字符串s前若干的字符相匹配的所有列表中的字符串，然后将剩下字符串s剩下的部分重复上述步骤。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//都多少次了，一定要记住啊，面试时可不会让你随意百度。</span></span><br><span class="line">            <span class="comment">//重要：substring方法截取出来的字符串包括起始索引，不包括终止索引。</span></span><br><span class="line">            <span class="keyword">if</span> (s.length() &gt;= word.length() &amp;&amp; s.substring(<span class="number">0</span>,word.length()).equals(word)) &#123;</span><br><span class="line">               ans = wordBreak(s.substring(word.length(),s.length()),wordDict);</span><br><span class="line">               <span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-HashSet"><a href="#方法二：动态规划-HashSet" class="headerlink" title="方法二：动态规划+HashSet"></a>方法二：动态规划+HashSet</h3><p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//集合Set具有输入参数类型为List的构造函数。</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态dp[i]表示字符串s的前i个字符所组成的字符串是否可拆分。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程：每个状态dp[i]前它前面的其他状态都有关。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j,i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [3,2,0,-4]<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [1,2]<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a></p>
<hr>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：HashSet-1"><a href="#方法二：HashSet-1" class="headerlink" title="方法二：HashSet"></a>方法二：HashSet</h3><p><strong>思路：每经过一个节点，就查询集合是否已存在该节点，不存在则加入集合中。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表加强"><a href="#142-环形链表加强" class="headerlink" title="142.环形链表加强"></a>142.环形链表加强</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p>
<hr>
<h3 id="方法一：双指针-1"><a href="#方法一：双指针-1" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong><u>思路：这里其实是三指针法，当快慢指针相遇时，此时第三个指针从头部出发，同时慢指针继续前进，当两者相遇时，根据数学计算可得，它们相遇的点即为入环节点。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode pos = head;</span><br><span class="line">                <span class="keyword">while</span> (pos != slow) &#123;</span><br><span class="line">                    pos = pos.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146.LRU缓存机制"></a>146.LRU缓存机制</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1。</li>
<li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例：</p>
<blockquote>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]<br>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a></p>
<hr>
<h3 id="方法一：HashMap-双向链表"><a href="#方法一：HashMap-双向链表" class="headerlink" title="方法一：HashMap+双向链表"></a>方法一：HashMap+双向链表</h3><p><strong>其实我自己已经想到了这两个数据结构，但就是不知道怎么去应用和编写。</strong></p>
<p><strong><u>一般这种专门考察数据结构应用的题目，面试官期望我们能够自己实现一个双向链表，而不是使用语言自带的。</u></strong></p>
<p><strong>get和put方法时间复杂度：O(1)</strong></p>
<p><strong>空间复杂度：O(capacity)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己实现链表就必须先定义好链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNote</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNote prev;</span><br><span class="line">        DLinkedNote next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNote</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNote</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存中以链表节点为值所组成的键值对表</span></span><br><span class="line">    HashMap&lt;Integer,DLinkedNote&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//缓存中键值对的数目</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//缓存中键值对的极限数目</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//缓存中存储数据的节点所在双向链表的头结点和尾节点</span></span><br><span class="line">    DLinkedNote head;</span><br><span class="line">    DLinkedNote tail;</span><br><span class="line">    <span class="comment">//其实综上也可以看出：在一个设备中所要运用的数据往往并不是以一种单一的数据结构存储在存储器中，</span></span><br><span class="line">    <span class="comment">//而是以不同数据之间不同的关联形式，在逻辑上以多种数据结构同时使用的形式存储的。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存结构初始化时，创建好伪头结点和伪尾节点，其实就是分别指向双向链表头部和尾部的指针。</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNote();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNote();</span><br><span class="line">        head.prev = tail;</span><br><span class="line">        tail.next = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为想要达到时间复杂度为O(1)，所以必须通过HashMap.get()方法来获取键值对节点，该方法的时间复杂度就是O(1)。</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            DLinkedNote curr = map.get(key);</span><br><span class="line">            DLinkedNote temp = curr.prev;</span><br><span class="line">            temp.next = curr.next;</span><br><span class="line">            curr.next.prev = temp;</span><br><span class="line">            head.prev.next = curr;</span><br><span class="line">            curr.next = head;</span><br><span class="line">            curr.prev = head.prev;</span><br><span class="line">            head.prev = curr;</span><br><span class="line">            <span class="keyword">return</span> curr.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;<span class="comment">//若该键已经存在，则直接替换该键值对的值，并更改该节点的位置到头部。</span></span><br><span class="line">            <span class="comment">//更改值</span></span><br><span class="line">            DLinkedNote curr = map.get(key);</span><br><span class="line">            curr.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将节点移到头部</span></span><br><span class="line">            DLinkedNote temp = curr.prev;</span><br><span class="line">            temp.next = curr.next;</span><br><span class="line">            curr.next.prev = temp;</span><br><span class="line">            head.prev.next = curr;</span><br><span class="line">            curr.next = head;</span><br><span class="line">            curr.prev = head.prev;</span><br><span class="line">            head.prev = curr;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (size &lt; capacity)&#123;<span class="comment">//缓存容量够，直接添加节点。</span></span><br><span class="line">            DLinkedNote curr = <span class="keyword">new</span> DLinkedNote(key,value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：因为按本题要求，链表节点中的键值对中的key是不能重复的，那么我们就可以直接把这个key的数值来作为哈希表中的key的数值。</span></span><br><span class="line">            <span class="comment">//本质上两者是有区别的，节点中的键值对中的key是具有实际意义要使用的数据，哈希表中的key是我们为了逻辑性保存数据所构建的无实际意义的数值。</span></span><br><span class="line">            map.put(key,curr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新节点加到双向链表最后</span></span><br><span class="line">            head.prev.next = curr;</span><br><span class="line">            curr.next = head;</span><br><span class="line">            curr.prev = head.prev;</span><br><span class="line">            head.prev = curr;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//缓存容量不够，先删除尾部节点再添加新节点。</span></span><br><span class="line">            <span class="comment">//删除链表和哈希表中的尾节点</span></span><br><span class="line">            DLinkedNote delete = tail.next;</span><br><span class="line">            map.remove(delete.key);</span><br><span class="line">            delete.next.prev = tail;</span><br><span class="line">            tail.next = delete.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新节点添加到链表头部和哈希表中</span></span><br><span class="line">            DLinkedNote curr = <span class="keyword">new</span> DLinkedNote(key,value);</span><br><span class="line">            map.put(key,curr);</span><br><span class="line">            head.prev.next = curr;</span><br><span class="line">            curr.next = head;</span><br><span class="line">            curr.prev = head.prev;</span><br><span class="line">            head.prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [4,2,1,3]<br>输出：[1,2,3,4]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = []<br>输出：[]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/sort-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list</a></p>
<hr>
<h3 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h3><p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt></p>
<p><strong><u>不要求多了，至少前面5中排序算法的原理、复杂度、实现必须要掌握。</u></strong></p>
<h3 id="方法一：插入排序"><a href="#方法一：插入排序" class="headerlink" title="方法一：插入排序"></a>方法一：插入排序</h3><p><strong>思路：重建一个新链表，将原链表中的节点一个一个按大小顺序添加到新链表当中去。</strong></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新链表的哑节点</span></span><br><span class="line">        ListNode ya = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode curr = ya;</span><br><span class="line">            <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; head.val &gt; curr.next.val) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode change = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line">            curr.next = change;</span><br><span class="line">            change.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ya.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归实现的归并排序"><a href="#方法二：递归实现的归并排序" class="headerlink" title="方法二：递归实现的归并排序"></a>方法二：递归实现的归并排序</h3><p><strong>思路：</strong></p>
<ul>
<li><strong>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</strong></li>
<li><strong>使用递归对两个子链表分别排序。</strong></li>
<li><strong>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用<a href="https://littleforestjia.github.io/2020/09/28/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener">21. 合并两个有序链表</a>的做法，将两个有序的子链表进行合并。</strong></li>
</ul>
<p><strong>时间复杂度：O(nlogn)<u>（可以看出复杂度中出现logn的两种常见情况：二分法、递归）</u></strong></p>
<p><strong>空间复杂度：O(logn)<u>（空间复杂度主要是由递归造成的，递归的空间复杂度一般都是O(logn)，将递归转换成迭代即可减小空间复杂度。）</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归法将无序链表排列为有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置快慢指针，用来找到链表的中间位置。这一步是并归的关键步骤1。</span></span><br><span class="line">        <span class="comment">//(重要：如果这里直接使fast=head会出大问题，结合关键步骤2中的语句，会使得长度为2的链表分成长度为2的第一段链表和长度为0的第二段链表。)</span></span><br><span class="line">        ListNode slow = head,fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以slow节点以前的节点(包括slow节点)为第一段，以后的节点为第二段。这一步是并归的关键步骤2。</span></span><br><span class="line">        ListNode secend = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(sortList(head),sortList(secend));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归法合并两个有序链表为一个有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode n1,ListNode n2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span>) <span class="keyword">return</span> n2;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="keyword">null</span>) <span class="keyword">return</span> n1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n1.val &lt; n2.val) &#123;</span><br><span class="line">            n1.next = merge(n1.next,n2);</span><br><span class="line">            <span class="keyword">return</span> n1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            n2.next = merge(n1,n2.next);</span><br><span class="line">            <span class="keyword">return</span> n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：迭代实现的归并排序"><a href="#方法三：迭代实现的归并排序" class="headerlink" title="方法三：迭代实现的归并排序"></a>方法三：迭代实现的归并排序</h3><p><strong>时间复杂度：O(nlogn)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<p><strong>具体实现代码不再复写，就上将方法二中的两个递归函数中的递归改成迭代。</strong></p>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a>152.乘积最大子数组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a></p>
<hr>
<h3 id="方法一：动态规划-9"><a href="#方法一：动态规划-9" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong>本题与题[53.最大子序和]有一定类似，但又有所不同，因为本题中的乘积要考虑负负得正。</strong></p>
<p><strong><u>考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个fmin(i)，它表示以第i个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：</u></strong></p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png" alt></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>],min = nums[<span class="number">0</span>],ans = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//要先把max记录一下，因为求min时要使用本次循环中还没有改变的max.</span></span><br><span class="line">            <span class="keyword">int</span> tempMax = max;</span><br><span class="line">            max = Math.max(max * nums[i],Math.max(min * nums[i],nums[i]));</span><br><span class="line">            min = Math.min(tempMax * nums[i],Math.min(min * nums[i],nums[i]));</span><br><span class="line">            ans = Math.max(ans,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p>示例:</p>
<blockquote>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]<br>输出：<br>[null,null,null,null,-3,null,0,-2]<br>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a></p>
<hr>
<h3 id="方法一：辅助栈"><a href="#方法一：辅助栈" class="headerlink" title="方法一：辅助栈"></a>方法一：辅助栈</h3><p><strong><u>在原有保存数据栈的基础之上再创建一个栈来保存每个栈顶元素对应的最小元素，也就是说两个栈长度始终相等，辅助栈中每个元素为数据栈中对应元素为栈顶时，数据栈中的最小元素值。</u></strong></p>
<p><strong>四个操作的时间复杂度均为：O(1)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; mainStack;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helpStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (helpStack.isEmpty()) &#123;</span><br><span class="line">            helpStack.push(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helpStack.push(helpStack.peek() &gt; x ? x : helpStack.peek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainStack.pop();</span><br><span class="line">        helpStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helpStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>示例 1：</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C1.png" alt></p>
<blockquote>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
</blockquote>
<p>示例 2：</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C2.png" alt></p>
<blockquote>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
</blockquote>
<p>示例 3：</p>
<p><img src="//littleforestjia.github.io/2020/09/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E7%83%AD%E9%97%A8100%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%5C3.png" alt></p>
<blockquote>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a></p>
<hr>
<h3 id="方法一：双指针-2"><a href="#方法一：双指针-2" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong>用暴力法或者HashSet当然都可以，只不过一个时间复杂度高了，一个空间复杂度高了。</strong></p>
<p><strong><u>使用双指针，一个遍历A+B，一个遍历B+A，若A、B相交，则两指针必相遇，且相遇点即为相交点；不相交则遍历到底也不相遇。</u></strong></p>
<p><strong>时间复杂度：O(m+n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pA = headA,pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != <span class="keyword">null</span> || pB != <span class="keyword">null</span>) &#123;<span class="comment">//两指针同时为null则说明不相遇，A、B不相交。</span></span><br><span class="line">            <span class="keyword">if</span> (pA == pB) <span class="keyword">return</span> pA;</span><br><span class="line">            <span class="keyword">if</span> (pA == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pA = headB;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pB == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">                pB = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：[3,2,3]<br>输出：3</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：[2,2,1,1,1,2,2]<br>输出：2</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/majority-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element</a></p>
<hr>
<h3 id="方法一：摩尔投票法"><a href="#方法一：摩尔投票法" class="headerlink" title="方法一：摩尔投票法"></a>方法一：摩尔投票法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>],vote = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans != nums[i]) &#123;</span><br><span class="line">                vote--;</span><br><span class="line">                <span class="keyword">if</span> (vote == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = nums[i];</span><br><span class="line">                    vote ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> vote++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机4"><a href="#188-买卖股票的最佳时机4" class="headerlink" title="188.买卖股票的最佳时机4"></a>188.买卖股票的最佳时机4</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a></p>
<hr>
<h3 id="方法一：动态规划-10"><a href="#方法一：动态规划-10" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>本题就是在<a href>【力扣刷题】_123.买卖股票的最佳时机3</a>的基础之上进行改写即可。</strong></u></p>
<p><strong>时间复杂度：O(kn)</strong></p>
<p><strong>空间复杂度：O(k)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态</span></span><br><span class="line">        <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(buy,-prices[<span class="number">0</span>]);</span><br><span class="line">        Arrays.fill(sell,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy[<span class="number">0</span>] = Math.max(buy[<span class="number">0</span>],-prices[i]);</span><br><span class="line">            sell[<span class="number">0</span>] = Math.max(sell[<span class="number">0</span>],buy[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                buy[j] = Math.max(buy[j],sell[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                sell[j] = Math.max(sell[j],buy[j] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sell[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p>
<hr>
<h3 id="方法一：动态规划-11"><a href="#方法一：动态规划-11" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：dp[i]表示有i个房屋时，小偷所能偷到的最大钱财。</span></span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp2 = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dp1;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = Math.max(temp + nums[i - <span class="number">1</span>],dp2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a></p>
<hr>
<h3 id="方法一：递归-4"><a href="#方法一：递归-4" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><u><strong>岛屿问题的本质实际上就是矩阵网格结构的递归遍历问题，这类问题最关键的难点就是某节点是否已经遍历过了的判断。</strong></u></p>
<p><u><strong>思路：将所有已经遍历过了的陆地格子的值改写成’0’。</strong></u></p>
<p><strong>时间复杂度：O(mn)</strong></p>
<p><strong>空间复杂度：O(mn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    noIsland(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把一个岛全部挖成海，也就是把表示一个岛的一片'1'全部变成'0'。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noIsland</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.length || column &lt; <span class="number">0</span> || column &gt;= grid[<span class="number">0</span>].length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[row][column] == <span class="string">'0'</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[row][column] = <span class="string">'0'</span>;</span><br><span class="line">        noIsland(grid,row - <span class="number">1</span>,column);</span><br><span class="line">        noIsland(grid,row + <span class="number">1</span>,column);</span><br><span class="line">        noIsland(grid,row,column - <span class="number">1</span>);</span><br><span class="line">        noIsland(grid,row,column + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>反转一个单链表。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a></p>
<hr>
<h3 id="方法一：递归-5"><a href="#方法一：递归-5" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong><u>该题的递归方法是巧思，要硬记。</u></strong></p>
<p><strong>经过这道题的递归方法，感觉自己对于递归的理解和递归的变式还是掌握得不够充分。</strong></p>
<p><strong><u>思路：本题的关键，将head.next作为递归方法的输入参数之后，head的next属性还是指向原来哪个节点的，只不过哪个节点现在变成了一个链表的尾端。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为后面head.next.next语句要用到head.next节点中的属性，所以head.next也不能为空，要将这种情况排除。</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode ans = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.课程表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a></p>
<hr>
<p><u><strong>本题的解题思路是通过拓扑排序判断此课程安排图是否是有向无环图(DAG)。</strong></u></p>
<p><u><strong>拓扑排序原理：对DAG的顶点进行排序，使得对每一条有向边 (u,v)，均有u（在排序记录中）比v先出现。亦可理解为对某点v而言，只有当v的所有源点均出现了，v才能出现。</strong></u></p>
<h3 id="方法一：广度优先遍历BFS"><a href="#方法一：广度优先遍历BFS" class="headerlink" title="方法一：广度优先遍历BFS"></a>方法一：广度优先遍历BFS</h3><p><u><strong>把课程编号看作图的节点，先决条件看作有向边。</strong></u></p>
<p><u><strong>用一个数组记录图中每个节点的入度，也就是被多少条有向边作为被指向端；并用动态数组记录每个节点所指向的其他节点。</strong></u></p>
<p><u><strong>维护一个队列，每次把入度为0的节点放入队列中，一个一个删除队列中的节点，并把被删除节点所指向的所有节点的入度都减1，再重复维护该队列直到队列为空。最后如果还剩下了节点没有被删，则就是组成环的节点和边；如果没有节点了，则说明图中没有环。</strong></u></p>
<p><strong>时间复杂度O(N+M)： 遍历一个图需要访问所有节点和所有临边，N和M分别为节点数量和临边数量；</strong></p>
<p><strong>空间复杂度O(N+M)： 为建立邻接表所需额外空间，邻接表edge长度为N，并存储M条临边的数据。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为此处的所有n个节点直接由数字0~n-1表示，所以数组的索引可以直接表示节点。</span></span><br><span class="line">        <span class="comment">//如果不是这样的节点表示形式，则应该用HashMap&lt;node,List&lt;node&gt;&gt;数据类型来建立邻接表，保存每个节点所指向节点的数组集合。</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先不管每个节点有没有指出的边，先给每个节点创建好记录指向节点的列表。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edge.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每一条有向边，记录每个节点的入度和所指向的节点</span></span><br><span class="line">        <span class="keyword">int</span> n = prerequisites.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先决条件[a,b]表示上a课程之前必须先上b课程，所以我们把它看成一条从b指向a的有向边。</span></span><br><span class="line">            indegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            edge.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将入度为0的节点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次删除一个入度为0的节点时，节点数减1</span></span><br><span class="line">            numCourses--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.get(temp).size(); i++) &#123;</span><br><span class="line">                indegree[edge.get(temp).get(i)]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[edge.get(temp).get(i)] == <span class="number">0</span>) queue.offer(edge.get(temp).get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：深度优先遍历DFS-递归"><a href="#方法二：深度优先遍历DFS-递归" class="headerlink" title="方法二：深度优先遍历DFS/递归"></a>方法二：深度优先遍历DFS/递归</h3><p><u><strong>这个递归也非常重要，也是递归中的一个巧思。</strong></u></p>
<p><u><strong>思路：创建一个辅助数组，用来记录图中每个节点的被访问状态，0表示未被访问，-1表示在以其他节点为起点沿有向边进行访问时被访问过，1表示在以该节点为起点沿有向边进行访问时被访问过。</strong></u></p>
<p><u><strong>我们依次对图中每一个节点进行递归访问，若节点状态为-1则表示之前访问也没出问题，不用再访问；若节点状态为1表示出现了环，直接返回false。</strong></u></p>
<p><strong>时间复杂度O(N+M)</strong></p>
<p><strong>空间复杂度O(N+M)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edge.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            edge.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(edge,i,mark)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; edge,<span class="keyword">int</span> node,<span class="keyword">int</span>[] mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[node] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mark[node] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        mark[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.get(node).size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(edge,edge.get(node).get(i),mark)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次判断完一个节点后序没有形成一个环就可以直接标记该节点已经被其他起点访问过了，</span></span><br><span class="line">        <span class="comment">//因为是深度优先，递归方法已经结束的话说明已经递归到了最深处还是没有环，则该节点没问题。</span></span><br><span class="line">        mark[node] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="208-实现Trie前缀树"><a href="#208-实现Trie前缀树" class="headerlink" title="208.实现Trie前缀树"></a>208.实现Trie前缀树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<blockquote>
<p>Trie trie = new Trie();</p>
<p>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree</a></p>
<hr>
<h3 id="方法一：Trie前缀树的实现"><a href="#方法一：Trie前缀树的实现" class="headerlink" title="方法一：Trie前缀树的实现"></a>方法一：Trie前缀树的实现</h3><p><strong>本题实际上就是前缀树Trie的基本实现，帮助我们理解前缀树这种数据结构的原理。</strong></p>
<p><strong>前缀树一般就是用来保存只含有小写字符的字符串，其实一般就是用来保存一个HashMap的所有key。</strong></p>
<p><strong><u>前缀树数据结构中最重要的同样是节点和节点中对于其他节点的链接，只不过前缀树中的节点中只有是否为终点这个特有属性，剩下的就是表示链接的节点数组。前缀树中每个节点一共可以有26个节点链接，用数组来表示，每个对应的数组索引用来表示一个特定的字符。比如List[0]不为空时，表示该节点中存有字符’a’这个链接，并通过它指向下一个节点。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先定义好前缀树节点类，可定义在前缀树内，也可定义在前缀树外。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前缀树中节点本身无具有实际意义的数据，字符是作为链接节点的形式保存在节点中的。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：这个数组用来保存链接，也就是节点，每个特定索引位置中的节点对应一个特定的字符。</span></span><br><span class="line">        <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            links = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.links[c - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.links[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> c,TrieNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若数组中该位置的元素之前不为空，则用新node覆盖原node。</span></span><br><span class="line">            links[c - <span class="string">'a'</span>] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word.length();</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (temp.containsKey(c)) temp = temp.get(c);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.put(c,<span class="keyword">new</span> TrieNode());</span><br><span class="line">                temp = temp.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word.length();</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.containsKey(word.charAt(i))) temp = temp.get(word.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prefix.length();</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.containsKey(prefix.charAt(i))) temp = temp.get(prefix.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><strong><u>重要：如果是全局变量，包装类Boolean是会被默认赋值为null,而基础类型boolean会被默认赋值为false的，该赋值过程应该是在类加载的时候赋值的。如果是局部变量，当你不赋值去使用的时候，编译器会直接报错，所以局部变量肯定是没有默认值的。</u></strong></p>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215.数组中的第K个最大元素"></a>215.数组中的第K个最大元素</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a></p>
<hr>
<h3 id="方法一：堆排序"><a href="#方法一：堆排序" class="headerlink" title="方法一：堆排序"></a>方法一：堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列中的比较器默认排序规则为正序，小的在前，大的在后，转换成堆就是小的在上，大的在下，也就是小根堆。</span></span><br><span class="line">        <span class="comment">//此处我们需要重写比较器比较方法，实现大根堆。</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：matrix = [[“0”]]<br>输出：0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/maximal-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square</a></p>
<hr>
<h3 id="方法一：动态规划-12"><a href="#方法一：动态规划-12" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：以matrix[i][j]为右下角的最大正方形的边长</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans = Math.max(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans = Math.max(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//其实就是判断最下边和最右边这两条边的长度，其中最小的就是该正方形的长度。</span></span><br><span class="line">                <span class="keyword">int</span> row = <span class="number">0</span>,column = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j - k] == <span class="string">'1'</span>) row++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i - k][j] == <span class="string">'1'</span>) column++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(row,column);</span><br><span class="line">                ans = Math.max(dp[i][j],ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划简化"><a href="#方法二：动态规划简化" class="headerlink" title="方法二：动态规划简化"></a>方法二：动态规划简化</h3><p><strong>在我自己写的基础之上优化了一步。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：以matrix[i][j]为右下角的最大正方形的边长</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans = Math.max(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans = Math.max(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    ans = Math.max(dp[i][j], ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<blockquote>
<p>​     4</p>
<p>   /   <br>  2     7<br> / \   / <br>1   3 6   9</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>​     4</p>
<p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a></p>
<hr>
<h3 id="方法一：递归-6"><a href="#方法一：递归-6" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2<br>输出: false</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list</a></p>
<hr>
<h3 id="方法一：辅助栈-1"><a href="#方法一：辅助栈-1" class="headerlink" title="方法一：辅助栈"></a>方法一：辅助栈</h3><p><strong><u>回文串：回文串就是正读和反读都一样的字符串</u></strong></p>
<p><strong>思路：先找到链表中点，把前半段入栈，后半段依次与栈顶比较，相同则出栈，不同则不是回文链表，最后栈为空则为回文链表。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快指针最开始一般直接指向第二个节点head.next。</span></span><br><span class="line">        ListNode fast = head,slow = head.next;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; slow.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            count++;</span><br><span class="line">            slow = slow.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：如果快指针最后指向空，说明链表中节点数量为奇数，慢指针此时指向中间节点；</span></span><br><span class="line">        <span class="comment">//如果最后不指向空，说明链表中节点数量为偶数，慢指针此时指向前半段的最后一个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (slow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val == stack.pop()) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双指针-2"><a href="#方法二：双指针-2" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p><strong><u>寻找链表中点，并在此过程中反转前半段链表，然后双指针从中点分别往左右出发，不同则不是回文链表，直到走到两端都相同则为回文链表。</u></strong><br><strong>时间复杂度：O(n)</strong><br><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head,fast = head.next,pre = <span class="keyword">null</span>,next = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode left,right;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            left = pre;</span><br><span class="line">            right = next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            left = slow;</span><br><span class="line">            right = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val == right.val) &#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p>示例 1:</p>
<blockquote>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a></p>
<hr>
<h3 id="方法一：递归-7"><a href="#方法一：递归-7" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>本题需要我们依靠自己的智慧去定义当该方法返回值为null时代表什么。</strong></p>
<p><strong><u>非常重要：此处我们定义当该方法返回null时表示p、q全都不在该二叉树root中。</u></strong></p>
<p>该方法比我自己想出来的方法<a href="https://littleforestjia.github.io/2021/01/12/%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9868_2.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" target="_blank" rel="noopener">【剑指刷题】_面试题68_2.二叉树的最近公共祖先</a>要简洁多了，还是硬记这种吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用该递归方法判断出p、q是否全不在左子树中</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="comment">//使用该递归方法判断出p、q是否全不在右子树中</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：这就表示全部在左子树中，返回右子树中查找的结果即可。</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：这就表示全部在右子树中，返回左子树中查找的结果即可。</span></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：以上两种情况都不符合，则说明两个目标节点分别分布在左右子树中，最近公共祖先即为该根节点。</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238.除自身以外数组的乘积"></a>238.除自身以外数组的乘积</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p>示例:</p>
<blockquote>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self" target="_blank" rel="noopener">https://leetcode-cn.com/problems/product-of-array-except-self</a></p>
<hr>
<h3 id="方法一：巧思"><a href="#方法一：巧思" class="headerlink" title="方法一：巧思"></a>方法一：巧思</h3><p><strong>巧思题：遍历两边，第一遍把每个元素左边的元素都乘起来放入该位置。第二遍从后往前把每个元素右边的元素都乘起来再乘上左边元素的乘积。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        output[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            output[i] = output[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次遍历</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = temp * nums[i];</span><br><span class="line">            output[i - <span class="number">1</span>] = output[i - <span class="number">1</span>] * temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [1], k = 1<br>输出：[1]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums = [1,-1], k = 1<br>输出：[1,-1]</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：nums = [9,11], k = 2<br>输出：[11]</p>
</blockquote>
<p>示例 5：</p>
<blockquote>
<p>输入：nums = [4,-2], k = 2<br>输出：[4]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a></p>
<hr>
<h3 id="方法一：辅助队列"><a href="#方法一：辅助队列" class="headerlink" title="方法一：辅助队列"></a>方法一：辅助队列</h3><p><strong>思路：创建一个辅助队列，保存当前窗口中依次从大到小的数值，每次删除数值时查看是不是删除了尾部最大元素；每次添加数值时查看是不是添加进了比头部元素大的数值，是则将当前头部元素先删除，直到头部元素不小于新增元素，再把新增元素放入辅助队列头部。</strong></p>
<p><strong><u>因为这里要查看队头和队尾的元素，所以用双端队列。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span> - k];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; deque.peekFirst()) deque.pollFirst();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = deque.peekLast();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == deque.peekLast()) deque.pollLast();</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k + i] &gt; deque.peekFirst()) deque.pollFirst();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(nums[k + i]);</span><br><span class="line">            ans[i + <span class="number">1</span>] = deque.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵2"><a href="#240-搜索二维矩阵2" class="headerlink" title="240.搜索二维矩阵2"></a>240.搜索二维矩阵2</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br>输出：true</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br>输出：false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-a-2d-matrix-ii</a></p>
<hr>
<h3 id="方法一：巧思-1"><a href="#方法一：巧思-1" class="headerlink" title="方法一：巧思"></a>方法一：巧思</h3><p><strong>巧思题。</strong></p>
<p><strong>思路：从矩阵的右上角开始寻找，当前格子元素大于target则将格子左移，当格子元素小于target则将格子右移，重复上述步骤直到找到该元素或超出矩阵。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length,m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>,column = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][column] &gt; target) column--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &lt; target) row++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares</a></p>
<hr>
<h3 id="方法一：动态规划-13"><a href="#方法一：动态规划-13" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>巧思题，要硬记。</u></strong></p>
<p><strong>思路：就是利用动态规划前面的数据，通过枚举比较得出每一个数的最少完全平方数个数。</strong></p>
<p><strong>时间复杂度：O(n^1.5)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态：dp[i]表示数字i最少由多少个完全平方数组成</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//先赋上一个最大的值，也就是该数全部由完全平方数1组成。</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：本题的关键，for循环终止条件表达式可以是一个复杂的计算表达式。</span></span><br><span class="line">            <span class="comment">//其中i - j * j = 0的情况就是该数就是一个完全平方数的情况。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<blockquote>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a></p>
<hr>
<h3 id="方法一：双指针-3"><a href="#方法一：双指针-3" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong><u>思路：左指针指向已处理好序列中首个零，右指针指向未处理序列的首个元素。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; n &amp;&amp; nums[left] != <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt;= left) right++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = <span class="number">0</span>;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [1,3,4,2,2]<br>输出：2</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [3,1,3,4,2]<br>输出：3</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums = [1,1]<br>输出：1</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：nums = [1,1,2]<br>输出：1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number</a></p>
<hr>
<h3 id="方法一：原地置换"><a href="#方法一：原地置换" class="headerlink" title="方法一：原地置换"></a>方法一：原地置换</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p>思路与<a href="https://littleforestjia.github.io/2020/11/08/%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%983.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">【剑指刷题】_面试题3.数组中重复的数字</a>相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297.二叉树的序列化与反序列化"></a>297.二叉树的序列化与反序列化</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>示例 1：</p>
<blockquote>
<p>​    1</p>
<p>   / <br>  2   3<br>     / <br>    4   5</p>
<p>输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：root = []<br>输出：[]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：root = [1]<br>输出：[1]</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：root = [1,2]<br>输出：[1,2]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree</a></p>
<hr>
<h3 id="方法一：层序遍历-辅助队列"><a href="#方法一：层序遍历-辅助队列" class="headerlink" title="方法一：层序遍历+辅助队列"></a>方法一：层序遍历+辅助队列</h3><p><strong><u>要将一个二叉树序列化其实也就是要将一个二叉树与一个唯一的字符串对应起来。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="comment">//将每个实际存在的节点的null子节点全部加入序列中。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"["</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">                sb.append(temp.val).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="comment">//重要：二叉树的反序列化同样要用到队列的辅助，这不过这次辅助队列中只放不为空的节点。</span></span><br><span class="line">    <span class="comment">//每次从队列头部中取出一个节点时，数组指针接下来所指的两个元素就刚好时该节点的子节点，</span></span><br><span class="line">    <span class="comment">//这时如果这两个子节点不为空则将它们加入队列，并放到刚取出节点的左右子节点位置。然后接着循环进行以上操作，直到队列为空。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String a = data.substring(<span class="number">1</span>,n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String.split("*")方法可以将字符串以*字符参数为分隔符，分割成一个字符串数组。</span></span><br><span class="line">        String[] b = a.split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(b[<span class="number">0</span>]));</span><br><span class="line">        TreeNode head = root;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该整数值用来记录遍历到了字符串数组中的哪一个字符串了。</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            root = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!b[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">                TreeNode temp = <span class="keyword">new</span> TreeNode(Integer.parseInt(b[i]));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每一个加入队列的节点在加入队列的同时也添加在了二叉树上。</span></span><br><span class="line">                queue.offer(temp);</span><br><span class="line">                root.left = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!b[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">                TreeNode temp = <span class="keyword">new</span> TreeNode(Integer.parseInt(b[i]));</span><br><span class="line">                queue.offer(temp);</span><br><span class="line">                root.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
<hr>
<h3 id="方法一：动态规划-14"><a href="#方法一：动态规划-14" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>巧思题，要硬记</strong></u></p>
<p><u><strong>一定要理解的一个关键点：如果一个数比它的前面某一个数小那么该数一定不在递增子序列中。因为如果该数在递增子序列中，那么它前面那个数比它大也一定可以进入递增子序列中，那么如果它前面那个数进入了递增子序列，该数自己就一定不能进入递增子序列。</strong></u></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i]表示以第i个元素为结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//状态转移方程：将某个数与它前面每个数都比较依次，找出最大的递增子序列长度即为所求。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重要：dp[i]表示以第i个元素结尾的递增子序列的长度，所以当nums[j]&gt;=nums[i]的情况根本不用考虑，</span></span><br><span class="line">                <span class="comment">//第i个元素无法与以第j个元素结尾的递增子序列组成一个递增子序列。</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用来记录整个数组的最长递增子序列的长度。</span></span><br><span class="line">            ans = Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301.删除无效的括号"></a>301.删除无效的括号</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p>
<p>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “()())()”<br>输出: [“()()()”, “(())()”]</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: “(a)())()”<br>输出: [“(a)()()”, “(a())()”]</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: “)(“<br>输出: [“”]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-invalid-parentheses</a></p>
<hr>
<h3 id="方法一：递归回溯-1"><a href="#方法一：递归回溯-1" class="headerlink" title="方法一：递归回溯"></a>方法一：递归回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>,left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        dfs(ans,s,<span class="number">0</span>,sb,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; ans,String s,<span class="keyword">int</span> index,StringBuilder sb,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans.isEmpty()) &#123;</span><br><span class="line">                    ans.add(sb.toString());</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//一旦有更长的字符串出现，去除列表中原来所有字符串。</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sb.length() &gt; ans.get(<span class="number">0</span>).length()) &#123;</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.add(sb.toString());</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//保证列表中不含重复的字符串</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sb.length() == ans.get(<span class="number">0</span>).length()) &#123;</span><br><span class="line">                    String temp = sb.toString();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp.equals(ans.get(i))) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans.add(temp);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index) == <span class="string">'('</span>) &#123;</span><br><span class="line">            dfs(ans,s,index + <span class="number">1</span>,sb,left,right);</span><br><span class="line">            sb.append(<span class="string">'('</span>);</span><br><span class="line">            dfs(ans,s,index + <span class="number">1</span>,sb,left + <span class="number">1</span>,right);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                dfs(ans,s,index + <span class="number">1</span>,sb,left,right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(ans,s,index + <span class="number">1</span>,sb,left,right);</span><br><span class="line">                sb.append(<span class="string">')'</span>);</span><br><span class="line">                dfs(ans,s,index + <span class="number">1</span>,sb,left,right + <span class="number">1</span>);</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(s.charAt(index));</span><br><span class="line">            dfs(ans, s, index + <span class="number">1</span>, sb, left, right);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例:</p>
<blockquote>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p>
<hr>
<h3 id="方法一：动态规划-15"><a href="#方法一：动态规划-15" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路：把买入股票看作亏钱，卖出股票看作赚钱，主要考虑三种状态，持有股票、冷冻期、卖出了股票且非冷冻期。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[][i]表示第i天结束时用户所能赚到的最多的钱：</span></span><br><span class="line">        <span class="comment">//dp[0][i]表示第i天手上持有着股票，可能是之前买的，也可能就是这天买的；</span></span><br><span class="line">        <span class="comment">//dp[1][i]表示第i天刚好是卖出日的情况，第i+1天不能买入；</span></span><br><span class="line">        <span class="comment">//dp[2][i]表示第i天是卖出一天以后的情况的情况，第i+1天可以买入。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.max(dp[<span class="number">2</span>][i - <span class="number">1</span>] - prices[i],dp[<span class="number">0</span>][i - <span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + prices[i];</span><br><span class="line">            dp[<span class="number">2</span>][i] = Math.max(dp[<span class="number">2</span>][i - <span class="number">1</span>],dp[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">1</span>][n - <span class="number">1</span>],dp[<span class="number">2</span>][n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312.戳气球"></a>312.戳气球</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; []<br>coins =  3<em>1</em>5    +   3<em>5</em>8   +  1<em>3</em>8  + 1<em>8</em>1 = 167</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [1,5]<br>输出：10</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/burst-balloons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/burst-balloons</a></p>
<hr>
<h3 id="方法一：递归-动态规划"><a href="#方法一：递归-动态规划" class="headerlink" title="方法一：递归+动态规划"></a>方法一：递归+动态规划</h3><p><strong><u>巧思题，要硬记。</u></strong></p>
<p><em>这种题目出出来纯粹就是恶心人的！！！</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i][j]表示戳爆第i个气球和第j个气球中间的所有气球所得到的最大硬币数。</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在原队列的起初上一头一尾加上数值为1的两个气球组成新队列。</span></span><br><span class="line">    <span class="keyword">int</span>[] numbers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        numbers = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        numbers[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            numbers[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coins(<span class="number">0</span>,n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已被改变，说明该值已经在之前的递归过程中计算过了，不用再次递归计算。</span></span><br><span class="line">        <span class="keyword">if</span> (dp[left][right] != -<span class="number">1</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意这里要考虑left~i和i~right之前的气球已经被戳报了，在i两端的两个气球就是left和right。</span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i] * numbers[left] * numbers[right];</span><br><span class="line">            dp[left][right] = Math.max(dp[left][right],temp + coins(left,i) + coins(i,right));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【力扣刷题】-322-零钱兑换"><a href="#【力扣刷题】-322-零钱兑换" class="headerlink" title="【力扣刷题】_322.零钱兑换"></a>【力扣刷题】_322.零钱兑换</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：coins = [2], amount = 3<br>输出：-1</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：coins = [1], amount = 1<br>输出：1</p>
</blockquote>
<p>示例 5：</p>
<blockquote>
<p>输入：coins = [1], amount = 2<br>输出：2</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change</a></p>
<hr>
<h3 id="方法一：动态规划-16"><a href="#方法一：动态规划-16" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>非常重要，思路与<a href="https://littleforestjia.github.io/2021/01/20/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/" target="_blank" rel="noopener">【力扣刷题】_279.完全平方数</a>思路相似。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i]表示总额i的最小硬币组成个数。</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(dp,amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j]) dp[i] = Math.min(dp[i],dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[amount]&gt;amount则说明dp[amount]根本没有被赋值过，说明没有硬币值可以组成该总额。</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="337-打家劫舍3"><a href="#337-打家劫舍3" class="headerlink" title="337.打家劫舍3"></a>337.打家劫舍3</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [3,2,3,null,3,null,1]</p>
<p>​     3<br>    / \</p>
<p>   2   3<br>    \   \<br>     3   1</p>
<p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [3,4,5,1,3,null,1]</p>
<pre><code> 3
/ \</code></pre><p>   4   5<br>  / \   \<br> 1   3   1</p>
<p>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii</a></p>
<hr>
<h3 id="方法一：递归-8"><a href="#方法一：递归-8" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong><u>本方法思路与<a href="https://littleforestjia.github.io/2021/01/13/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/" target="_blank" rel="noopener">【力扣刷题】_198.打家劫舍</a>的思路相似，在此基础上改写。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(root.left) + rob(root.right),root.val + (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : (rob(root.left.left) + rob(root.left.right))) + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : (rob(root.right.left) + rob(root.right.right))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归-动态规划-HashMap"><a href="#方法二：递归-动态规划-HashMap" class="headerlink" title="方法二：递归+动态规划+HashMap"></a>方法二：递归+动态规划+HashMap</h3><p><strong><u>由于第一种方法中需要对很多节点重复使用rob方法进行计算，浪费了大量时间，可以采用<a href="https://littleforestjia.github.io/2021/01/27/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_312.%E6%88%B3%E6%B0%94%E7%90%83/" target="_blank" rel="noopener">【力扣刷题】_312.戳气球</a>中记忆化递归的思路进行优化，每对一个节点使用rob方法，则将该计算值保存到哈希表中。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> robnode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robnode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(root)) <span class="keyword">return</span> map.get(root);</span><br><span class="line">        <span class="keyword">int</span> ans = Math.max(robnode(root.left) + robnode(root.right),root.val + (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : (robnode(root.left.left) + robnode(root.left.right))) + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : (robnode(root.right.left) + robnode(root.right.right))));</span><br><span class="line">        map.put(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 2<br>输出: [0,1,1]</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 5<br>输出: [0,1,1,2,1,2]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/counting-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/counting-bits</a></p>
<hr>
<h3 id="方法一：暴力法-5"><a href="#方法一：暴力法-5" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; <span class="number">1</span>) != <span class="number">0</span>) ans[i]++;</span><br><span class="line">                temp = temp &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-3"><a href="#方法二：动态规划-3" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路：位运算i&amp;(i-1)得到的就是将i的二进制表达式从右往左第一个1变成0，所表示的数。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            ans[i] = ans[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347.前K个高频元素"></a>347.前K个高频元素</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements</a></p>
<hr>
<h3 id="方法一：优先队列-HashMap"><a href="#方法一：优先队列-HashMap" class="headerlink" title="方法一：优先队列+HashMap"></a>方法一：优先队列+HashMap</h3><p><strong><u>类似<a href="https://littleforestjia.github.io/2021/01/08/%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9840.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/" target="_blank" rel="noopener">面试题40.最小的k个数</a>中的堆排序方法的思路，不同之处是本题中自定义优先队列的比较器为比较哈希表中的值。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每个不相等的元素及其出现次数存入哈希表中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i])) map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> map.put(nums[i],map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列中的正序就是小的值放在二叉树的上面，也就是小根堆；逆序就是大的值放在二叉树的上面，也就是大根堆。</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//逆序就是第二个参数减第一个参数</span></span><br><span class="line">                <span class="keyword">return</span> map.get(o2) - map.get(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap.keySet()方法用于获取哈希表中的所有key并返回一个Set。</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i:map.keySet()) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394.字符串解码"></a>394.字符串解码</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s = “3[a]2[bc]”<br>输出：”aaabcbc”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：s = “3[a2[c]]”<br>输出：”accaccacc”</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：s = “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：s = “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/decode-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string</a></p>
<hr>
<h3 id="方法一：递归-9"><a href="#方法一：递归-9" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>存粹就是体力活，没有太多技术含量。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decode(s,-<span class="number">1</span>,s.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> qian = <span class="number">0</span>,hou = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">'a'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                qian = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//表示循环次数的数字可能不止一位。</span></span><br><span class="line">                <span class="keyword">while</span> (s.charAt(qian) != <span class="string">'['</span>) &#123;</span><br><span class="line">                    qian++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个flag用来标志前括号是不是找到了自己对应的后括号。</span></span><br><span class="line">                flag++;</span><br><span class="line"></span><br><span class="line">                hou  = qian + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找到第一个前括号自己对应的后括号。</span></span><br><span class="line">                <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(hou) == <span class="string">'['</span>) &#123;</span><br><span class="line">                        flag++;</span><br><span class="line">                        hou++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(hou) == <span class="string">']'</span>) &#123;</span><br><span class="line">                        flag--;</span><br><span class="line">                        hou++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> hou++;</span><br><span class="line">                &#125;</span><br><span class="line">                hou--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Integer.parseInt(s.substring(i,qian)); j++) &#123;</span><br><span class="line">                    sb.append(decode(s,qian,hou));</span><br><span class="line">                &#125;</span><br><span class="line">                i = hou;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="399-除法求职"><a href="#399-除法求职" class="headerlink" title="399.除法求职"></a>399.除法求职</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p>
<p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p>
<p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br>输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]<br>解释：<br>条件：a / b = 2.0, b / c = 3.0<br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br>输出：[3.75000,0.40000,5.00000,0.20000]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br>输出：[0.50000,2.00000,-1.00000,-1.00000]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/evaluate-division" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-division</a></p>
<hr>
<h3 id="方法一：带权并查集"><a href="#方法一：带权并查集" class="headerlink" title="方法一：带权并查集"></a>方法一：带权并查集</h3><p><u><strong>非常重要，详细解释可以自行查看答案解析。</strong></u></p>
<p><u><strong>本质上给到我们的数据描述的是一个有向图，有向图问题常用带权并查集方法解决。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = equations.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以两倍equations.size()的大小创建一个并查集，就算存在重复的字符串导致并不需要这么多节点，</span></span><br><span class="line">        <span class="comment">//但是多出来的每个节点自成一个集合，并不会影响我们的正常运算，所以不用去管多出来的那些节点就好了。</span></span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">2</span> * n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个哈希表字典，将每个字符串与一个数字编号绑定，因为我们一般直接用从0开始的数字表示并查集中的节点。</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String s1 = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String s2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(s1)) &#123;</span><br><span class="line">                hashMap.put(s1,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(s2)) &#123;</span><br><span class="line">                hashMap.put(s2,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(hashMap.get(s1),hashMap.get(s2),values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            String s1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String s2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：注意这里数据类型一定要是Integer，因为Integer的值可以为null，int的值不能为null。</span></span><br><span class="line">            Integer id1 = hashMap.get(s1);</span><br><span class="line">            Integer id2 = hashMap.get(s2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重要：先检查id1和id2是不是都存在，如果哈希表中没有键s1或s2则get方法会返回null。</span></span><br><span class="line">            <span class="keyword">if</span> (id1 == <span class="keyword">null</span> || id2 == <span class="keyword">null</span>) ans[i] = -<span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i] = unionFind.isConnected(id1,id2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个带权并查集</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//parent[i]表示节点i的父节点，并查集中每个节点只有一个父节点。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//weight[i]表示节点i到父节点的权值。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] weight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个并查集往往由一个或多个集合组成，每个集合有一个节点，根节点指向它自己。</span></span><br><span class="line">        <span class="comment">//并查集初始化时，使每个节点指向自己，也就是每个节点自成一个集合，权值为1。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            weight = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归寻找节点x的根节点，并压缩节点x到根节点的路径，使节点x直接指向根节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//x自己就是根节点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> father = parent[x];</span><br><span class="line">            parent[x] = find(father);</span><br><span class="line">            weight[x] = weight[x] * weight[father];</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看节点x和节点y是否在同一个集合中，如果在则返回x指向y的权值，不在则返回-1。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画图可以更好理解该计算公式。</span></span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span> weight[x] / weight[y];</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给定节点x指向节点y的权值，将并查集中这两个节点所在的集合结合成一个集合。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这两个节点在同一个结合中，直接返回。</span></span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画图可以更好理解该计算公式。</span></span><br><span class="line">            weight[rootX] = weight[y] * value / weight[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height</a></p>
<hr>
<h3 id="方法一：从低到高考虑"><a href="#方法一：从低到高考虑" class="headerlink" title="方法一：从低到高考虑"></a>方法一：从低到高考虑</h3><p><strong><u>巧思题，要硬记。</u></strong></p>
<p><strong>思路：先将原队列按身高排好序。如果我们在初始时建立一个包含n个位置的空队列，而我们每次将一个人放入队列中时，会将一个「空」位置变成「满」位置，那么当我们放入第i个人时，我们需要给他安排一个「空」位置，并且这个「空」位置前面恰好还有ki个「空」位置，用来安排给后面身高更高的人。也就是说，第i个人的位置，就是队列中从左往右数第ki+1 个「空」位置。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = people.length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = people[i][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[j] == <span class="keyword">null</span>) index--;</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans[j] = people[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<ul>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ul>
<p>示例 1:</p>
<blockquote>
<p>输入: [1, 5, 11, 5]</p>
<p>输出: true</p>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [1, 2, 3, 5]</p>
<p>输出: false</p>
<p>解释: 数组不能分割成两个元素和相等的子集.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a></p>
<hr>
<h3 id="方法一：动态规划-17"><a href="#方法一：动态规划-17" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>重要关键点：将本体转化成一个这样的判断问题：使用数组中的一部分元素相加，能不能组成数组总额的一半，其中每个元素最多使用一次。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总和分不成两份，所以直接返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示使用第0~i位置的元素中的一部分相加能否得到和j。</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= sum / <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; j) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//没有用上第i个元素的情况和用上了第i个元素的情况，只要有一个满足true就行。</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="「力扣」上的-0-1-背包问题："><a href="#「力扣」上的-0-1-背包问题：" class="headerlink" title="「力扣」上的 0-1 背包问题："></a>「力扣」上的 0-1 背包问题：</h4><p>「力扣」第 416 题：分割等和子集（中等）；<br>「力扣」第 474 题：一和零（中等）；<br>「力扣」第 494 题：目标和（中等）；<br>「力扣」第 879 题：盈利计划（困难）；</p>
<h4 id="「力扣」上的-完全背包问题："><a href="#「力扣」上的-完全背包问题：" class="headerlink" title="「力扣」上的 完全背包问题："></a>「力扣」上的 完全背包问题：</h4><p>「力扣」第 322 题：零钱兑换（中等）；<br>「力扣」第 518 题：零钱兑换 II（中等）；<br>「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。</p>
<h2 id="437-路径总和3"><a href="#437-路径总和3" class="headerlink" title="437.路径总和3"></a>437.路径总和3</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<blockquote>
<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<p>​     10<br>     /  <br>    5   -3</p>
<p>   / \    <br>  3   2   11<br> / \   <br>3  -2   1</p>
<p>返回 3。和等于 8 的路径有:</p>
<p>5 -&gt; 3</p>
<p>5 -&gt; 2 -&gt; 1</p>
<p>-3 -&gt; 11</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/path-sum-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-iii</a></p>
<hr>
<h3 id="方法一：递归-10"><a href="#方法一：递归-10" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        sum(root,sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        isPath(root,sum);</span><br><span class="line">        sum(root.left,sum);</span><br><span class="line">        sum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum == root.val) ans++;</span><br><span class="line">        isPath(root.left,sum - root.val);</span><br><span class="line">        isPath(root.right,sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<ul>
<li>字母异位词指字母相同，但排列不同的字符串。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<p>示例 1:</p>
<blockquote>
<p>输入:<br>s: “cbaebabacd” p: “abc”</p>
<p>输出:<br>[0, 6]</p>
<p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。</p>
</blockquote>
<p> 示例 2:</p>
<blockquote>
<p>输入:<br>s: “abab” p: “ab”</p>
<p>输出:<br>[0, 1, 2]</p>
<p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string</a></p>
<hr>
<h3 id="方法一：滑动窗口-1"><a href="#方法一：滑动窗口-1" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(),n = p.length();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            array1[p.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            array2[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array1[i] != array2[i]) <span class="keyword">break</span>;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">26</span>) ans.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; m; i++) &#123;</span><br><span class="line">            array2[s.charAt(i - n) - <span class="string">'a'</span>]--;</span><br><span class="line">            array2[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array1[j] != array2[j]) <span class="keyword">break</span>;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">26</span>) ans.add(i - n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<blockquote>
<p>输入:<br>[4,3,2,7,8,2,3,1]</p>
<p>输出:<br>[5,6]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a></p>
<hr>
<h3 id="方法一：原地置换-1"><a href="#方法一：原地置换-1" class="headerlink" title="方法一：原地置换"></a>方法一：原地置换</h3><p><strong>老问题<a href="https://littleforestjia.github.io/2021/01/21/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/" target="_blank" rel="noopener">【力扣刷题】_287.寻找重复数</a>的升级版了，做了挺多次了。</strong></p>
<p><strong><u>原地置换方法的关键：自己在草稿纸上画一个例子，然后画出置换过程，辅助编写代码。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[temp] != nums[i]) &#123;</span><br><span class="line">                    nums[i] = nums[temp];</span><br><span class="line">                    nums[temp] = temp + <span class="number">1</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>注意：<br>0 ≤ x, y &lt; 2^31.</p>
<p>示例:</p>
<blockquote>
<p>输入: x = 1, y = 4</p>
<p>输出: 2</p>
<p>解释:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p>
<p>上面的箭头指出了对应二进制位不同的位置。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/hamming-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hamming-distance</a></p>
<hr>
<h3 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m &amp; <span class="number">1</span>) == <span class="number">1</span>) ans++;</span><br><span class="line">            m = m &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<blockquote>
<p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5<br>解释：</p>
<p>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p>
<p>一共有5种方法让最终目标和为3。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/target-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/target-sum</a></p>
<hr>
<h3 id="方法一：递归-11"><a href="#方法一：递归-11" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        findWays(nums,<span class="number">0</span>,S);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWays</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == S) ans++;</span><br><span class="line">            <span class="keyword">if</span> (-nums[index] == S) ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findWays(nums,index + <span class="number">1</span>,S - nums[index]);</span><br><span class="line">        findWays(nums,index + <span class="number">1</span>,S + nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-4"><a href="#方法二：动态规划-4" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><strong>其实也可以转化成一个背包问题，如<a href="https://littleforestjia.github.io/2021/02/01/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/" target="_blank" rel="noopener">【力扣刷题】_416.分割等和子集</a>。</strong></p>
<p><strong>但是这里涉及正负，状态的定义就要考虑很复杂的边界问题，比寻常背包问题麻烦多了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示由前i个元素组成S的可能种数。(S有可能为负数但是在-1000~1000这个范围内，所以矩阵列数S+1001一定为正数)</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] + <span class="number">1000</span> &gt;= <span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] + <span class="number">1000</span> &lt; <span class="number">2001</span>) dp[<span class="number">0</span>][nums[<span class="number">0</span>] + <span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (-nums[<span class="number">0</span>] + <span class="number">1000</span> &gt;= <span class="number">0</span> &amp;&amp; -nums[<span class="number">0</span>] + <span class="number">1000</span> &lt; <span class="number">2001</span>) dp[<span class="number">0</span>][-nums[<span class="number">0</span>] + <span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2001</span>; j++) &#123;</span><br><span class="line">                dp[i][j] = ((j - nums[i] &gt;= <span class="number">0</span> &amp;&amp; j - nums[i] &lt; <span class="number">2001</span>) ? dp[i - <span class="number">1</span>][j - nums[i]] : <span class="number">0</span>) + ((j + nums[i] &gt;= <span class="number">0</span> &amp;&amp; j + nums[i] &lt; <span class="number">2001</span>) ? dp[i - <span class="number">1</span>][j + nums[i]] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (S + <span class="number">1000</span> &gt;= <span class="number">0</span> &amp;&amp; S + <span class="number">1000</span> &lt; <span class="number">2001</span>) <span class="keyword">return</span> dp[n - <span class="number">1</span>][S + <span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p>示例 1：</p>
<blockquote>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：root = [0,null,1]<br>输出：[1,null,1]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：root = [1,0,2]<br>输出：[3,3,2]</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：root = [3,2,4,1]<br>输出：[7,9,4,10]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p>
<hr>
<h3 id="方法一：从右往左中序遍历"><a href="#方法一：从右往左中序遍历" class="headerlink" title="方法一：从右往左中序遍历"></a>方法一：从右往左中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历递归方法，并返回最后访问的节点的节点值。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        sum = sum + root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 :</p>
<blockquote>
<p>给定二叉树</p>
<p>​       1<br>      / <br>    2   3</p>
<p>   / \<br>  4   5    </p>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree</a></p>
<hr>
<h3 id="方法一：递归-12"><a href="#方法一：递归-12" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><u><strong>二叉树中的这种路径最多也就只有一个转折点，也就是说最多也就是先升后降，不可能有多次转折。</strong></u></p>
<p><u><strong>本方法采用类似于后序遍历的递归，避免了重复计算同一个节点的深度，极大减小了时间复杂度。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        longSide(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longSide</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = longSide(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = longSide(root.right);</span><br><span class="line">        ans = Math.max(ans,left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560.和为K的子数组"></a>560.和为K的子数组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<blockquote>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k</a></p>
<hr>
<h3 id="方法一：HashMap"><a href="#方法一：HashMap" class="headerlink" title="方法一：HashMap"></a>方法一：HashMap</h3><p><strong><u>巧思题，要硬记。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                ans += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = map.get(sum);</span><br><span class="line">                map.put(sum,count + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> map.put(sum,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581.最短无序连续子数组"></a>581.最短无序连续子数组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [1,2,3,4]<br>输出：0</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums = [1]<br>输出：0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a></p>
<hr>
<h3 id="方法一：巧思-2"><a href="#方法一：巧思-2" class="headerlink" title="方法一：巧思"></a>方法一：巧思</h3><p><strong><u>首先我们需要找到原数组在哪个位置开始不是升序的。我们从头开始遍历数组，一旦遇到降序的元素，我们记录最小元素为 min。类似的，我们逆序扫描数组 nums，当数组出现升序的时候，我们记录最大元素为 max。然后，我们再次遍历 nums 数组并通过与其他元素进行比较，来找到 min 和 max 在原数组中的正确位置。我们只需要从头开始找到第一个大于 min 的元素，从尾开始找到第一个小于 max 的元素，它们之间就是最短无序子数组。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE,max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出现降序之后最小的一个数，这个数就是重新排序段在重新排序之后的起点。</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                min = Math.min(min,nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反向找出现升序之后最大的一个数，这个数就是重新排序段在重新排序之后的终点。</span></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                max = Math.max(max,nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从左往右找到第一个比min大的数即为重新排序段的起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; min) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右往左找到第一个比max小的数即为重新排序段的终点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; max) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<blockquote>
<p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a></p>
<hr>
<h3 id="方法一：递归-13"><a href="#方法一：递归-13" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode temp = <span class="keyword">new</span> TreeNode(t2.val,t2.left,t2.right);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647.回文子串"></a>647.回文子串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：”aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings</a></p>
<hr>
<h3 id="方法一：中心扩散法"><a href="#方法一：中心扩散法" class="headerlink" title="方法一：中心扩散法"></a>方法一：中心扩散法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - count &gt;= <span class="number">0</span> &amp;&amp; i + count &lt; n &amp;&amp; s.charAt(i - count) == s.charAt(i + count)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - count &gt;= <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> + count &lt; n &amp;&amp; s.charAt(i - count) == s.charAt(i + <span class="number">1</span> + count)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a></p>
<hr>
<h3 id="方法一：动态规划-18"><a href="#方法一：动态规划-18" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>本题主要在<a href>【力扣刷题】_309.最佳买卖股票时机含冷冻期</a>的基础上进行改写即可。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化</span></span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy = Math.max(buy, sell - prices[i]);</span><br><span class="line">            sell = Math.max(sell,buy + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<blockquote>
<p>给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p>
<hr>
<h3 id="方法一：辅助栈-2"><a href="#方法一：辅助栈-2" class="headerlink" title="方法一：辅助栈"></a>方法一：辅助栈</h3><p><strong><u>创建两个栈，主栈保存从下到上单调递减的温度数据，辅栈中保存主栈中每一个温度在数组中的位置。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; index = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!temp.isEmpty() &amp;&amp; T[i] &gt; temp.peek()) &#123;</span><br><span class="line">                temp.pop();</span><br><span class="line">                <span class="keyword">int</span> tmp = index.pop();</span><br><span class="line">                ans[tmp] = i - tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push(T[i]);</span><br><span class="line">            index.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!index.isEmpty()) &#123;</span><br><span class="line">            ans[index.pop()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/25/%E3%80%90%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E3%80%91_%E8%BF%90%E5%8A%A8%E5%81%A5%E8%BA%AB%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" rel="next" title="【日常生活】_运动健身知识积累">
                <i class="fa fa-chevron-left"></i> 【日常生活】_运动健身知识积累
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/09/%E3%80%90%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E3%80%91_%E4%BC%97%E5%8C%85%E8%AE%BE%E8%AE%A1%E6%B4%BB%E5%8A%A8%E5%88%86%E8%A7%A3%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/" rel="prev" title="【科研项目】_众包设计活动分解工具开发">
                【科研项目】_众包设计活动分解工具开发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="zju岩手县小森" />
            
              <p class="site-author-name" itemprop="name">zju岩手县小森</p>
              <p class="site-description motion-element" itemprop="description">看的远固然重要 但是走好眼前的路才是关键</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/littleforestjia" target="_blank" title="Instagram">
                      Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/29623500" target="_blank" title="Bilibili">
                      Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-两数之和"><span class="nav-number">1.</span> <span class="nav-text">1.两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解读出来的隐藏信息："><span class="nav-number">1.1.</span> <span class="nav-text">解读出来的隐藏信息：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法"><span class="nav-number">1.2.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：两遍哈希表"><span class="nav-number">1.3.</span> <span class="nav-text">方法二：两遍哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：一遍哈希表"><span class="nav-number">1.4.</span> <span class="nav-text">方法三：一遍哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">1.5.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-两数相加"><span class="nav-number">2.</span> <span class="nav-text">2.两数相加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法：初等数学"><span class="nav-number">2.1.</span> <span class="nav-text">方法：初等数学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-1"><span class="nav-number">2.2.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-number">3.</span> <span class="nav-text">3.无重复字符的最长子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：滑动窗口"><span class="nav-number">3.1.</span> <span class="nav-text">方法一：滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-思路和算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.思路和算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-判断重复字符"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.判断重复字符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-寻找两个正序数组的中位数"><span class="nav-number">4.</span> <span class="nav-text">4.寻找两个正序数组的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：自己写的（迭代）"><span class="nav-number">4.1.</span> <span class="nav-text">方法一：自己写的（迭代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：二分查找"><span class="nav-number">4.2.</span> <span class="nav-text">方法二：二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">5.</span> <span class="nav-text">5.最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解读传来的隐藏信息："><span class="nav-number">5.1.</span> <span class="nav-text">解读传来的隐藏信息：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：我自己想出来的-中心扩散法"><span class="nav-number">5.2.</span> <span class="nav-text">方法一：我自己想出来的(中心扩散法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：暴力法-（Brute-Force）"><span class="nav-number">5.3.</span> <span class="nav-text">方法二：暴力法 （Brute Force）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：动态规划"><span class="nav-number">5.4.</span> <span class="nav-text">方法三：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-2"><span class="nav-number">5.5.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-正则表达式匹配-非常重要"><span class="nav-number">6.</span> <span class="nav-text">10.正则表达式匹配(非常重要)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划"><span class="nav-number">6.1.</span> <span class="nav-text">方法一：动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态规划的重要步骤"><span class="nav-number">6.1.1.</span> <span class="nav-text">动态规划的重要步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本题思路"><span class="nav-number">6.1.2.</span> <span class="nav-text">本题思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">6.2.</span> <span class="nav-text">****总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-盛最多水的容器"><span class="nav-number">7.</span> <span class="nav-text">11.盛最多水的容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：我自己写的-暴力法"><span class="nav-number">7.1.</span> <span class="nav-text">方法一：我自己写的(暴力法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双指针"><span class="nav-number">7.2.</span> <span class="nav-text">方法二：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-三数之和"><span class="nav-number">8.</span> <span class="nav-text">15.三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序-三重循环"><span class="nav-number">8.1.</span> <span class="nav-text">方法一：排序+三重循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：排序-双指针-自己写的"><span class="nav-number">8.2.</span> <span class="nav-text">方法二：排序+双指针(自己写的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：排序-双指针"><span class="nav-number">8.3.</span> <span class="nav-text">方法三：排序+双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-3"><span class="nav-number">8.4.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-电话号码的字母组合"><span class="nav-number">9.</span> <span class="nav-text">17.电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-自己写的"><span class="nav-number">9.1.</span> <span class="nav-text">方法一：递归回溯法(自己写的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：递归回溯法"><span class="nav-number">9.2.</span> <span class="nav-text">方法二：递归回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-4"><span class="nav-number">9.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-删除链表的倒数第N个节点"><span class="nav-number">10.</span> <span class="nav-text">19.删除链表的倒数第N个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：快慢指针-自己写的"><span class="nav-number">10.1.</span> <span class="nav-text">方法一：快慢指针(自己写的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：栈"><span class="nav-number">10.2.</span> <span class="nav-text">方法二：栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-5"><span class="nav-number">10.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">11.</span> <span class="nav-text">20.有效的括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：自己写的-栈"><span class="nav-number">11.1.</span> <span class="nav-text">方法一：自己写的(栈)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：栈-哈希表"><span class="nav-number">11.2.</span> <span class="nav-text">方法二：栈+哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">11.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-number">12.</span> <span class="nav-text">21.合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归法"><span class="nav-number">12.1.</span> <span class="nav-text">方法一：递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：迭代法"><span class="nav-number">12.2.</span> <span class="nav-text">方法二：迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-6"><span class="nav-number">12.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-括号生成"><span class="nav-number">13.</span> <span class="nav-text">22.括号生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法-1"><span class="nav-number">13.1.</span> <span class="nav-text">方法一：暴力法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">13.1.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：回溯法"><span class="nav-number">13.2.</span> <span class="nav-text">方法二：回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结："><span class="nav-number">13.2.1.</span> <span class="nav-text">小结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：动态规划递归（还没自己实现）"><span class="nav-number">13.3.</span> <span class="nav-text">方法三：动态规划递归（还没自己实现）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-合并K个升序链表"><span class="nav-number">14.</span> <span class="nav-text">23.合并K个升序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-顺序合并-自己写的"><span class="nav-number">14.1.</span> <span class="nav-text">方法一：递归+顺序合并(自己写的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-7"><span class="nav-number">14.2.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-下一个排列"><span class="nav-number">15.</span> <span class="nav-text">31.下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：一边扫描-栈"><span class="nav-number">15.1.</span> <span class="nav-text">方法一：一边扫描+栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-最长有效括号"><span class="nav-number">16.</span> <span class="nav-text">32.最长有效括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：枚举-栈-自己写的"><span class="nav-number">16.1.</span> <span class="nav-text">方法一：枚举+栈(自己写的)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非常重要的总结："><span class="nav-number">16.2.</span> <span class="nav-text">非常重要的总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划"><span class="nav-number">16.3.</span> <span class="nav-text">方法二：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：栈"><span class="nav-number">16.4.</span> <span class="nav-text">方法三：栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法四：判断括号字符串有效的两个条件"><span class="nav-number">16.5.</span> <span class="nav-text">方法四：判断括号字符串有效的两个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-8"><span class="nav-number">16.6.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-number">17.</span> <span class="nav-text">33.搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二分搜索"><span class="nav-number">17.1.</span> <span class="nav-text">方法一：二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-9"><span class="nav-number">17.2.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-number">18.</span> <span class="nav-text">34.在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二分搜索-1"><span class="nav-number">18.1.</span> <span class="nav-text">方法一：二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：-10"><span class="nav-number">18.2.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-组合总和"><span class="nav-number">19.</span> <span class="nav-text">39.组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法"><span class="nav-number">19.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-接雨水"><span class="nav-number">20.</span> <span class="nav-text">42.接雨水</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法-2"><span class="nav-number">20.1.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态编程"><span class="nav-number">20.2.</span> <span class="nav-text">方法二：动态编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：栈-1"><span class="nav-number">20.3.</span> <span class="nav-text">方法三：栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法四：双指针"><span class="nav-number">20.4.</span> <span class="nav-text">方法四：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-全排列"><span class="nav-number">21.</span> <span class="nav-text">46.全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：回溯法"><span class="nav-number">21.1.</span> <span class="nav-text">方法一：回溯法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-旋转图像"><span class="nav-number">22.</span> <span class="nav-text">48.旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：自己写的"><span class="nav-number">22.1.</span> <span class="nav-text">方法一：自己写的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-number">23.</span> <span class="nav-text">49.字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序数组分类"><span class="nav-number">23.1.</span> <span class="nav-text">方法一：排序数组分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：按字符计数分类"><span class="nav-number">23.2.</span> <span class="nav-text">方法二：按字符计数分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-最大子序和"><span class="nav-number">24.</span> <span class="nav-text">53.最大子序和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-1"><span class="nav-number">24.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-number">25.</span> <span class="nav-text">55.跳跃游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-1"><span class="nav-number">25.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：贪心法"><span class="nav-number">25.2.</span> <span class="nav-text">方法二：贪心法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-合并区间"><span class="nav-number">26.</span> <span class="nav-text">56.合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序"><span class="nav-number">26.1.</span> <span class="nav-text">方法一：排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-不同路径"><span class="nav-number">27.</span> <span class="nav-text">62.不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-2"><span class="nav-number">27.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-1"><span class="nav-number">27.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-最小路径和"><span class="nav-number">28.</span> <span class="nav-text">64.最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-2"><span class="nav-number">28.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">29.</span> <span class="nav-text">70.爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-3"><span class="nav-number">29.1.</span> <span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-2"><span class="nav-number">29.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">30.</span> <span class="nav-text">72.编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-4"><span class="nav-number">30.1.</span> <span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-4"><span class="nav-number">30.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-颜色分类"><span class="nav-number">31.</span> <span class="nav-text">75.颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法-3"><span class="nav-number">31.1.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双指针-1"><span class="nav-number">31.2.</span> <span class="nav-text">方法二：双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-5"><span class="nav-number">31.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76-最小覆盖子串"><span class="nav-number">32.</span> <span class="nav-text">76.最小覆盖子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：滑动窗口法"><span class="nav-number">32.1.</span> <span class="nav-text">方法一：滑动窗口法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路"><span class="nav-number">32.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤"><span class="nav-number">32.1.2.</span> <span class="nav-text">步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#78-子集"><span class="nav-number">33.</span> <span class="nav-text">78.子集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯"><span class="nav-number">33.1.</span> <span class="nav-text">方法一：递归回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79-单词搜索"><span class="nav-number">34.</span> <span class="nav-text">79.单词搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：深度优先搜索"><span class="nav-number">34.1.</span> <span class="nav-text">方法一：深度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-柱状图中最大的矩形"><span class="nav-number">35.</span> <span class="nav-text">84.柱状图中最大的矩形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法-4"><span class="nav-number">35.1.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：单调栈"><span class="nav-number">35.2.</span> <span class="nav-text">方法二：单调栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-6"><span class="nav-number">35.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85-最大矩形"><span class="nav-number">36.</span> <span class="nav-text">85.最大矩形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：柱状图-枚举高暴力法-动态规划"><span class="nav-number">36.1.</span> <span class="nav-text">方法一：柱状图_枚举高暴力法+动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：柱状图-枚举高单调栈优化-动态规划优化"><span class="nav-number">36.2.</span> <span class="nav-text">方法二：柱状图_枚举高单调栈优化+动态规划优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-7"><span class="nav-number">36.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-二叉树的中序遍历"><span class="nav-number">37.</span> <span class="nav-text">94.二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归"><span class="nav-number">37.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：栈-1"><span class="nav-number">37.2.</span> <span class="nav-text">方法二：栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-不同的二叉搜索树"><span class="nav-number">38.</span> <span class="nav-text">96.不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-5"><span class="nav-number">38.1.</span> <span class="nav-text">方法一：动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态："><span class="nav-number">38.1.1.</span> <span class="nav-text">状态：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态转移方程："><span class="nav-number">38.1.2.</span> <span class="nav-text">状态转移方程：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#98-验证二叉搜索树"><span class="nav-number">39.</span> <span class="nav-text">98.验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：中序遍历"><span class="nav-number">39.1.</span> <span class="nav-text">方法一：中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-对称二叉树"><span class="nav-number">40.</span> <span class="nav-text">101.对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：中序遍历-1"><span class="nav-number">40.1.</span> <span class="nav-text">方法一：中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：递归"><span class="nav-number">40.2.</span> <span class="nav-text">方法二：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-8"><span class="nav-number">40.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-二叉树的层序遍历"><span class="nav-number">41.</span> <span class="nav-text">102.二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：队列-广度优先搜索"><span class="nav-number">41.1.</span> <span class="nav-text">方法一：队列(广度优先搜索)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-number">42.</span> <span class="nav-text">104.二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-1"><span class="nav-number">42.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="nav-number">43.</span> <span class="nav-text">105.从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-2"><span class="nav-number">43.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-二叉树展开为链表"><span class="nav-number">44.</span> <span class="nav-text">114.二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：前序遍历"><span class="nav-number">44.1.</span> <span class="nav-text">方法一：前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：寻找前驱节点"><span class="nav-number">44.2.</span> <span class="nav-text">方法二：寻找前驱节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-买卖股票的最佳时机"><span class="nav-number">45.</span> <span class="nav-text">121.买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-6"><span class="nav-number">45.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-买卖股票的最佳时机2"><span class="nav-number">46.</span> <span class="nav-text">122.买卖股票的最佳时机2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-7"><span class="nav-number">46.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-买卖股票的最佳时机3"><span class="nav-number">47.</span> <span class="nav-text">123.买卖股票的最佳时机3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-8"><span class="nav-number">47.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#124-二叉树中的最大路径和"><span class="nav-number">48.</span> <span class="nav-text">124.二叉树中的最大路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-3"><span class="nav-number">48.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#128-最长连续序列"><span class="nav-number">49.</span> <span class="nav-text">128.最长连续序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序-动态规划"><span class="nav-number">49.1.</span> <span class="nav-text">方法一：排序+动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：HashSet"><span class="nav-number">49.2.</span> <span class="nav-text">方法二：HashSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-只出现一次的数字"><span class="nav-number">50.</span> <span class="nav-text">136.只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：HashSet"><span class="nav-number">50.1.</span> <span class="nav-text">方法一：HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：位运算"><span class="nav-number">50.2.</span> <span class="nav-text">方法二：位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">50.3.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">51.</span> <span class="nav-text">139.单词拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-3"><span class="nav-number">51.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-HashSet"><span class="nav-number">51.2.</span> <span class="nav-text">方法二：动态规划+HashSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-环形链表"><span class="nav-number">52.</span> <span class="nav-text">141.环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针"><span class="nav-number">52.1.</span> <span class="nav-text">方法一：双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：HashSet-1"><span class="nav-number">52.2.</span> <span class="nav-text">方法二：HashSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-环形链表加强"><span class="nav-number">53.</span> <span class="nav-text">142.环形链表加强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-1"><span class="nav-number">53.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU缓存机制"><span class="nav-number">54.</span> <span class="nav-text">146.LRU缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：HashMap-双向链表"><span class="nav-number">54.1.</span> <span class="nav-text">方法一：HashMap+双向链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-排序链表"><span class="nav-number">55.</span> <span class="nav-text">148.排序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#十大排序算法"><span class="nav-number">55.1.</span> <span class="nav-text">十大排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：插入排序"><span class="nav-number">55.2.</span> <span class="nav-text">方法一：插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：递归实现的归并排序"><span class="nav-number">55.3.</span> <span class="nav-text">方法二：递归实现的归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：迭代实现的归并排序"><span class="nav-number">55.4.</span> <span class="nav-text">方法三：迭代实现的归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-乘积最大子数组"><span class="nav-number">56.</span> <span class="nav-text">152.乘积最大子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-9"><span class="nav-number">56.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#155-最小栈"><span class="nav-number">57.</span> <span class="nav-text">155.最小栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助栈"><span class="nav-number">57.1.</span> <span class="nav-text">方法一：辅助栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-相交链表"><span class="nav-number">58.</span> <span class="nav-text">160.相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-2"><span class="nav-number">58.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-多数元素"><span class="nav-number">59.</span> <span class="nav-text">169.多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：摩尔投票法"><span class="nav-number">59.1.</span> <span class="nav-text">方法一：摩尔投票法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188-买卖股票的最佳时机4"><span class="nav-number">60.</span> <span class="nav-text">188.买卖股票的最佳时机4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-10"><span class="nav-number">60.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">61.</span> <span class="nav-text">198.打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-11"><span class="nav-number">61.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-岛屿数量"><span class="nav-number">62.</span> <span class="nav-text">200.岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-4"><span class="nav-number">62.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-反转链表"><span class="nav-number">63.</span> <span class="nav-text">206.反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-5"><span class="nav-number">63.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：迭代"><span class="nav-number">63.2.</span> <span class="nav-text">方法二：迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#207-课程表"><span class="nav-number">64.</span> <span class="nav-text">207.课程表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：广度优先遍历BFS"><span class="nav-number">64.1.</span> <span class="nav-text">方法一：广度优先遍历BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：深度优先遍历DFS-递归"><span class="nav-number">64.2.</span> <span class="nav-text">方法二：深度优先遍历DFS&#x2F;递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#208-实现Trie前缀树"><span class="nav-number">65.</span> <span class="nav-text">208.实现Trie前缀树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：Trie前缀树的实现"><span class="nav-number">65.1.</span> <span class="nav-text">方法一：Trie前缀树的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-9"><span class="nav-number">65.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-数组中的第K个最大元素"><span class="nav-number">66.</span> <span class="nav-text">215.数组中的第K个最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：堆排序"><span class="nav-number">66.1.</span> <span class="nav-text">方法一：堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-最大正方形"><span class="nav-number">67.</span> <span class="nav-text">221.最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-12"><span class="nav-number">67.1.</span> <span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划简化"><span class="nav-number">67.2.</span> <span class="nav-text">方法二：动态规划简化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-number">68.</span> <span class="nav-text">226.翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-6"><span class="nav-number">68.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-回文链表"><span class="nav-number">69.</span> <span class="nav-text">234.回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助栈-1"><span class="nav-number">69.1.</span> <span class="nav-text">方法一：辅助栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双指针-2"><span class="nav-number">69.2.</span> <span class="nav-text">方法二：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-二叉树的最近公共祖先"><span class="nav-number">70.</span> <span class="nav-text">236.二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-7"><span class="nav-number">70.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#238-除自身以外数组的乘积"><span class="nav-number">71.</span> <span class="nav-text">238.除自身以外数组的乘积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：巧思"><span class="nav-number">71.1.</span> <span class="nav-text">方法一：巧思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-滑动窗口最大值"><span class="nav-number">72.</span> <span class="nav-text">239.滑动窗口最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助队列"><span class="nav-number">72.1.</span> <span class="nav-text">方法一：辅助队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#240-搜索二维矩阵2"><span class="nav-number">73.</span> <span class="nav-text">240.搜索二维矩阵2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：巧思-1"><span class="nav-number">73.1.</span> <span class="nav-text">方法一：巧思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-完全平方数"><span class="nav-number">74.</span> <span class="nav-text">279.完全平方数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-13"><span class="nav-number">74.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-移动零"><span class="nav-number">75.</span> <span class="nav-text">283.移动零</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-3"><span class="nav-number">75.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#287-寻找重复数"><span class="nav-number">76.</span> <span class="nav-text">287.寻找重复数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：原地置换"><span class="nav-number">76.1.</span> <span class="nav-text">方法一：原地置换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#297-二叉树的序列化与反序列化"><span class="nav-number">77.</span> <span class="nav-text">297.二叉树的序列化与反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：层序遍历-辅助队列"><span class="nav-number">77.1.</span> <span class="nav-text">方法一：层序遍历+辅助队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-最长递增子序列"><span class="nav-number">78.</span> <span class="nav-text">300.最长递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-14"><span class="nav-number">78.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#301-删除无效的括号"><span class="nav-number">79.</span> <span class="nav-text">301.删除无效的括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯-1"><span class="nav-number">79.1.</span> <span class="nav-text">方法一：递归回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#309-最佳买卖股票时机含冷冻期"><span class="nav-number">80.</span> <span class="nav-text">309.最佳买卖股票时机含冷冻期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-15"><span class="nav-number">80.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-戳气球"><span class="nav-number">81.</span> <span class="nav-text">312.戳气球</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-动态规划"><span class="nav-number">81.1.</span> <span class="nav-text">方法一：递归+动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【力扣刷题】-322-零钱兑换"><span class="nav-number">82.</span> <span class="nav-text">【力扣刷题】_322.零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-16"><span class="nav-number">82.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-打家劫舍3"><span class="nav-number">83.</span> <span class="nav-text">337.打家劫舍3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-8"><span class="nav-number">83.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：递归-动态规划-HashMap"><span class="nav-number">83.2.</span> <span class="nav-text">方法二：递归+动态规划+HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#338-比特位计数"><span class="nav-number">84.</span> <span class="nav-text">338.比特位计数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法-5"><span class="nav-number">84.1.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-3"><span class="nav-number">84.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#347-前K个高频元素"><span class="nav-number">85.</span> <span class="nav-text">347.前K个高频元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：优先队列-HashMap"><span class="nav-number">85.1.</span> <span class="nav-text">方法一：优先队列+HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#394-字符串解码"><span class="nav-number">86.</span> <span class="nav-text">394.字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-9"><span class="nav-number">86.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#399-除法求职"><span class="nav-number">87.</span> <span class="nav-text">399.除法求职</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：带权并查集"><span class="nav-number">87.1.</span> <span class="nav-text">方法一：带权并查集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#406-根据身高重建队列"><span class="nav-number">88.</span> <span class="nav-text">406.根据身高重建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：从低到高考虑"><span class="nav-number">88.1.</span> <span class="nav-text">方法一：从低到高考虑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-分割等和子集"><span class="nav-number">89.</span> <span class="nav-text">416.分割等和子集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-17"><span class="nav-number">89.1.</span> <span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关问题"><span class="nav-number">89.2.</span> <span class="nav-text">相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#「力扣」上的-0-1-背包问题："><span class="nav-number">89.2.1.</span> <span class="nav-text">「力扣」上的 0-1 背包问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#「力扣」上的-完全背包问题："><span class="nav-number">89.2.2.</span> <span class="nav-text">「力扣」上的 完全背包问题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#437-路径总和3"><span class="nav-number">90.</span> <span class="nav-text">437.路径总和3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-10"><span class="nav-number">90.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#438-找到字符串中所有字母异位词"><span class="nav-number">91.</span> <span class="nav-text">438.找到字符串中所有字母异位词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：滑动窗口-1"><span class="nav-number">91.1.</span> <span class="nav-text">方法一：滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-number">92.</span> <span class="nav-text">448.找到所有数组中消失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：原地置换-1"><span class="nav-number">92.1.</span> <span class="nav-text">方法一：原地置换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#461-汉明距离"><span class="nav-number">93.</span> <span class="nav-text">461.汉明距离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：位运算"><span class="nav-number">93.1.</span> <span class="nav-text">方法一：位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494-目标和"><span class="nav-number">94.</span> <span class="nav-text">494.目标和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-11"><span class="nav-number">94.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-4"><span class="nav-number">94.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#538-把二叉搜索树转换为累加树"><span class="nav-number">95.</span> <span class="nav-text">538.把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：从右往左中序遍历"><span class="nav-number">95.1.</span> <span class="nav-text">方法一：从右往左中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#543-二叉树的直径"><span class="nav-number">96.</span> <span class="nav-text">543.二叉树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-12"><span class="nav-number">96.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#560-和为K的子数组"><span class="nav-number">97.</span> <span class="nav-text">560.和为K的子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：HashMap"><span class="nav-number">97.1.</span> <span class="nav-text">方法一：HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#581-最短无序连续子数组"><span class="nav-number">98.</span> <span class="nav-text">581.最短无序连续子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：巧思-2"><span class="nav-number">98.1.</span> <span class="nav-text">方法一：巧思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-合并二叉树"><span class="nav-number">99.</span> <span class="nav-text">617.合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-13"><span class="nav-number">99.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-回文子串"><span class="nav-number">100.</span> <span class="nav-text">647.回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：中心扩散法"><span class="nav-number">100.1.</span> <span class="nav-text">方法一：中心扩散法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#714-买卖股票的最佳时机含手续费"><span class="nav-number">101.</span> <span class="nav-text">714.买卖股票的最佳时机含手续费</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-18"><span class="nav-number">101.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#739-每日温度"><span class="nav-number">102.</span> <span class="nav-text">739.每日温度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助栈-2"><span class="nav-number">102.1.</span> <span class="nav-text">方法一：辅助栈</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zju岩手县小森</span>

  
</div>















        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
