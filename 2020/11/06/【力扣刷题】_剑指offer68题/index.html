<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="面试题2.实现singleton模式tips：代码块中的注解、加粗、下划线部分为重点内容。  1. 题目设计一个类，我们只能生成该类的一个实例。  2.单例模式单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。 优点：是不会频繁地创建和销毁对象，浪费系统资源。 使用场景：IO 、数据库连接、Redis 连接等。 3. 额外知识类">
<meta property="og:type" content="article">
<meta property="og:title" content="【力扣刷题】_剑指offer68题">
<meta property="og:url" content="http://https//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/index.html">
<meta property="og:site_name" content="岩手县小森的博客">
<meta property="og:description" content="面试题2.实现singleton模式tips：代码块中的注解、加粗、下划线部分为重点内容。  1. 题目设计一个类，我们只能生成该类的一个实例。  2.单例模式单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。 优点：是不会频繁地创建和销毁对象，浪费系统资源。 使用场景：IO 、数据库连接、Redis 连接等。 3. 额外知识类">
<meta property="og:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9836.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5C1.jpeg">
<meta property="og:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9836.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5C2.jpeg">
<meta property="og:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/1.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/2.png">
<meta property="og:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/3.png">
<meta property="article:published_time" content="2020-11-05T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-07T08:58:37.769Z">
<meta property="article:author" content="zju岩手县小森">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9836.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5C1.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://https://littleforestjia.github.io/2020/11/06/【力扣刷题】_剑指offer68题/"/>





  <title>【力扣刷题】_剑指offer68题 | 岩手县小森的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岩手县小森的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">努力将眼前的每一天过得精彩</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://https://littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zju岩手县小森">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岩手县小森的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【力扣刷题】_剑指offer68题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-06T00:00:00+08:00">
                2020-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">力扣刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="面试题2-实现singleton模式"><a href="#面试题2-实现singleton模式" class="headerlink" title="面试题2.实现singleton模式"></a>面试题2.实现singleton模式</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>设计一个类，我们只能生成该类的一个实例。</p>
<hr>
<h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p><u><strong>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</strong></u></p>
<p><u><strong>优点：是不会频繁地创建和销毁对象，浪费系统资源。</strong></u></p>
<p><u><strong>使用场景：IO 、数据库连接、Redis 连接等。</strong></u></p>
<h3 id="3-额外知识"><a href="#3-额外知识" class="headerlink" title="3. 额外知识"></a>3. 额外知识</h3><p><strong>类加载(classLoader)机制一般遵从下面的加载顺序：</strong></p>
<ul>
<li><p><strong>如果类还没有被加载：</strong></p>
<ol>
<li><u><strong>先执行父类的静态代码块和静态变量初始化，静态代码块和静态变量的执行顺序跟代码中出现的顺序有关。</strong></u></li>
<li><u><strong>执行子类的静态代码块和静态变量初始化。</strong></u></li>
<li><strong>执行父类的实例变量初始化</strong> <em>(Java的成员变量有两种：一种是静态变量又叫类变量；一种是实例变量，也就是非成员方法内变量。成员方法内定义的变量又分为全局变量和局部变量。<u>类变量是所有实例对象共有，其中一个实例对象将它的值改变，其他实例对象得到的就是改变后的结果；而实例变量则是每新建一个实例对象就会新建一个，某一个实例对象内将其值改变，不影响其他实例对象内的值。</u>)</em></li>
<li><strong>执行父类的构造函数</strong></li>
<li><strong>执行子类的实例变量初始化</strong></li>
<li><strong>执行子类的构造函数</strong></li>
</ol>
<p><strong>同时，加载类的过程是线程私有的，别的线程无法进入。</strong></p>
</li>
</ul>
<ul>
<li><p><u><strong>如果类已经被加载：</strong></u></p>
<p><u><strong>静态代码块和静态变量不在重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。</strong></u></p>
</li>
</ul>
<h3 id="4-方法一：饿汉模式"><a href="#4-方法一：饿汉模式" class="headerlink" title="4. 方法一：饿汉模式"></a>4. 方法一：饿汉模式</h3><p><strong>优点：类加载的时候创建一次实例，避免了多线程同步问题。</strong></p>
<p><strong>缺点：即使单例没被用到也会创建，浪费内存。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。</span></span><br><span class="line">    <span class="comment">//静态变量也被称为类变量，该变量在类被类加载器加载时就在jvm堆中分配了空间，并完成初始化赋值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同时为了避免单例的类被频繁创建对象，我们可以用private的构造函数来确保单例类无法被外部实例化。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static关键字用来声明独立于对象的静态方法，静态方法不能使用类的非静态变量。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-方法二：静态内部类"><a href="#5-方法二：静态内部类" class="headerlink" title="5. 方法二：静态内部类"></a>5. 方法二：静态内部类</h3><p><strong>只要程序中不使用内部类，JVM就不会去加载这个单例类，也不会创建单例对象，从而实现懒汉式的延迟加载。这种方式可以同时保证延迟加载和线程安全。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInternClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInternClass</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHodler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为类的静态属性只会在第一次加载类的时候初始化，也就保证了SingletonInstance中的对象只会被实例化一次。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInternClass INSTANCE = <span class="keyword">new</span> StaticInternClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成对象的实例化。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInternClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHodler.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题3-数组中重复的数字"><a href="#面试题3-数组中重复的数字" class="headerlink" title="面试题3.数组中重复的数字"></a>面试题3.数组中重复的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：<br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：遍历数组"><a href="#方法一：遍历数组" class="headerlink" title="方法一：遍历数组"></a>方法一：遍历数组</h3><p><strong><u>思路：利用集合中元素不可重复的特性</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中集合Set的常用实现类是HashSet</span></span><br><span class="line">        Set&lt;Integer&gt; numsSet= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Set.add()方法的返回值类型为boolean，表示输入参数是否成功添加到集合中去了，如果集合中已存在该元素则无法添加。</span></span><br><span class="line">            <span class="keyword">if</span> (!numsSet.add(nums[i])) &#123;</span><br><span class="line">                ans = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：原地置换-剑指offer原答案"><a href="#方法二：原地置换-剑指offer原答案" class="headerlink" title="方法二：原地置换(剑指offer原答案)"></a>方法二：原地置换(剑指offer原答案)</h3><p><strong>这种方法太巧妙了，只能背原题，让直接自己想出来是不可能的。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果满足该判断语句则表示不同位置索引nums[i]和i两处的值相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题4-二维数组中的查找"><a href="#面试题4-二维数组中的查找" class="headerlink" title="面试题4.二维数组中的查找"></a>面试题4.二维数组中的查找</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p> 示例:</p>
<p>现有矩阵 matrix 如下：</p>
<blockquote>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
</blockquote>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
<hr>
<h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p><strong>时间复杂度：O(n*m)</strong><br><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：线性查找"><a href="#方法二：线性查找" class="headerlink" title="方法二：线性查找"></a>方法二：线性查找</h3><p><strong><u>思路：从矩阵的右上角开始查找，如果元素比target大，则左移一位继续比较；如果元素比target小，则下移一位继续比较，循环上述步骤，知道找到target或者到达矩阵边界。（从矩阵的左下角开始查找一样可行）</u></strong></p>
<p><strong>时间复杂度：O(n+m)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length,m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>,column = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; n &amp;&amp; column &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[row][column]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[row][column]) column--;</span><br><span class="line">            <span class="keyword">else</span> row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题5-替换空格"><a href="#面试题5-替换空格" class="headerlink" title="面试题5.替换空格"></a>面试题5.替换空格</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：<br>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<p>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题6-从尾到头打印链表"><a href="#面试题6-从尾到头打印链表" class="headerlink" title="面试题6.从尾到头打印链表"></a>面试题6.从尾到头打印链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,3,2]<br>输出：[2,3,1]</p>
</blockquote>
<hr>
<h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; ints = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ints.push(head.val);</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            ans[i] = ints.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题7-重建二叉树"><a href="#面试题7-重建二叉树" class="headerlink" title="面试题7.重建二叉树"></a>面试题7.重建二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> 例如，给出</p>
<blockquote>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
</blockquote>
<p>返回如下的二叉树：</p>
<blockquote>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p>
<hr>
<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cut = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[<span class="number">0</span>]) &#123;</span><br><span class="line">                cut = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] leftpre = <span class="keyword">new</span> <span class="keyword">int</span>[cut];</span><br><span class="line">        <span class="keyword">int</span>[] leftin = <span class="keyword">new</span> <span class="keyword">int</span>[cut];</span><br><span class="line">        <span class="keyword">int</span>[] rightpre = <span class="keyword">new</span> <span class="keyword">int</span>[n - cut - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightin = <span class="keyword">new</span> <span class="keyword">int</span>[n - cut - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cut; i++) &#123;</span><br><span class="line">            leftpre[i] = preorder[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cut; i++) &#123;</span><br><span class="line">            leftin[i] = inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - cut - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            rightpre[i] = preorder[cut + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - cut - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            rightin[i] = inorder[cut + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        node.left = buildTree(leftpre,leftin);</span><br><span class="line">        node.right = buildTree(rightpre,rightin);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题9-用两个栈实现队列"><a href="#面试题9-用两个栈实现队列" class="headerlink" title="面试题9.用两个栈实现队列"></a>面试题9.用两个栈实现队列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p> 示例 1：</p>
<blockquote>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p>
<hr>
<h3 id="方法一：双栈"><a href="#方法一：双栈" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h3><p><strong><u>思路：使用左栈和右栈，左栈只负责压入数据，右栈只负责弹出数据，在每次弹出时检测右栈是否为空，为空则将左栈中数据全部移入右栈，如果左栈也为空说明该队列为空。</u></strong></p>
<p><strong>入队和出队时间复杂度：O(1)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; left;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        left.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!left.empty()) &#123;</span><br><span class="line">                    right.push(left.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题10-1-斐波那契数列"><a href="#面试题10-1-斐波那契数列" class="headerlink" title="面试题10_1.斐波那契数列"></a>面试题10_1.斐波那契数列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<blockquote>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
</blockquote>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 2<br>输出：1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 5<br>输出：5</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p>
<hr>
<h3 id="方法一：递归-1"><a href="#方法一：递归-1" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><u><strong>由于使用递归方法会进行大量重复的递归计算，所以非常容易超时。</strong></u></p>
<p><u><strong>这里我们采用简化的动态规划方法，可以达到在不增加空间复杂度的情况下减小时间复杂度。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择a、b作为状态变量，并初始化</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当n很大的时候可能会出现数字溢出，所以我们需要用结果对1000000007求余。</span></span><br><span class="line">            temp = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题10-2-青蛙跳台阶问题"><a href="#面试题10-2-青蛙跳台阶问题" class="headerlink" title="面试题10_2.青蛙跳台阶问题"></a>面试题10_2.青蛙跳台阶问题</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 2<br>输出：2</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 7<br>输出：21</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：n = 0<br>输出：1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p>
<hr>
<h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>思路：跳上n级台阶的最后一步有可能是直接从n-2级台阶直接跳上来，也有可能是从n-1级台阶跳上来，那么将这两种情况的跳法相加，即为结果。</u></strong></p>
<p><strong>本题采用优化的动态规划，简化了空间复杂度。</strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>,dp2 = <span class="number">2</span>,temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            temp = (dp1 + dp2) % <span class="number">1000000007</span>;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11.旋转数组的最小数字"></a>面试题11.旋转数组的最小数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<blockquote>
<p>输入：[3,4,5,1,2]<br>输出：1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：二分搜索"><a href="#方法一：二分搜索" class="headerlink" title="方法一：二分搜索"></a>方法一：二分搜索</h3><p><strong><u>重要：这道题的数组中可以包含相等元素，比不包含相等元素要难得多。</u></strong></p>
<p><strong>平均时间复杂度：O(logn)</strong></p>
<p><strong>最差时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = numbers.length - <span class="number">1</span>,mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这里这个+1非常重要，保证了每次循环范围都会缩小。</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//也就是numbers[mid]==numbers[right]的情况，则将右边界一个一个往左挪。</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><u><strong>非常重要：本题中要在每次循环中将中间点数值与右边界数值进行比较判断，而不能将中间点数值与左边界数值进行比较判断，否则会麻烦很多。</strong></u></p>
<p><u><strong>一定要注意，将中间点数值与左边界数值还是右边界数值比较是有不同意义的，在做题时可以尝试比较两者区别，选择更加合适比较方式。</strong></u></p>
<h2 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12.矩阵中的路径"></a>面试题12.矩阵中的路径</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p>
<hr>
<h3 id="方法一：递归回溯法"><a href="#方法一：递归回溯法" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><strong><u>用一个保存boolean类型值的矩阵保存每个格子是否已经被经过过。</u></strong></p>
<p><strong><u>空间复杂度：O(K)（k为递归层数，也就是字符串长度）</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length,m = board[<span class="number">0</span>].length,l = word.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stringExist(board,mark,l,<span class="number">0</span>,i,j,word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stringExist</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[][] mark,<span class="keyword">int</span> stringLength,<span class="keyword">int</span> index,<span class="keyword">int</span> row,<span class="keyword">int</span> column,String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stringLength == index) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (row &gt; -<span class="number">1</span> &amp;&amp; row &lt; board.length &amp;&amp; column &gt; -<span class="number">1</span> &amp;&amp; column &lt; board[<span class="number">0</span>].length &amp;&amp; board[row][column] == word.charAt(index) &amp;&amp; !mark[row][column]) &#123;</span><br><span class="line">            mark[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (stringExist(board,mark,stringLength,index + <span class="number">1</span>,row + <span class="number">1</span>,column,word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (stringExist(board,mark,stringLength,index + <span class="number">1</span>,row - <span class="number">1</span>,column,word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (stringExist(board,mark,stringLength,index + <span class="number">1</span>,row,column + <span class="number">1</span>,word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (stringExist(board,mark,stringLength,index + <span class="number">1</span>,row,column - <span class="number">1</span>,word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这一步非常重要，如果一条路失败了，一定不能忘记回溯。</span></span><br><span class="line">            mark[row][column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong><u>本题中的回溯代码很容易忘记写，一定不能忘了。深度优先遍历时，一条路走不通了换另一条路时一定要先回溯。</u></strong></p>
<h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13.机器人的运动范围"></a>面试题13.机器人的运动范围</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ </p>
<p>示例 1：</p>
<blockquote>
<p>输入：m = 2, n = 3, k = 1<br>输出：3</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：m = 3, n = 1, k = 0<br>输出：1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong>思路：机器人能到达的格子的上或左边的格子也一定能到达。</strong></p>
<p><strong>时间复杂度：O(mn)</strong></p>
<p><strong>空间复杂度：O(mn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：机器人能否到达该格子</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">this</span>.get(i) + <span class="keyword">this</span>.get(j) &lt;= k) &amp;&amp; ((((i - <span class="number">1</span>) &gt; -<span class="number">1</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]) || (((j - <span class="number">1</span>) &gt; -<span class="number">1</span>) &amp;&amp; dp[i][j - <span class="number">1</span>]))) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求十进制数x各位之和的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong><u>本题中求十进制数各位之和的方法写的比较简洁，可以记一下。</u></strong></p>
<h2 id="面试题14-1-剪绳子"><a href="#面试题14-1-剪绳子" class="headerlink" title="面试题14_1.剪绳子"></a>面试题14_1.剪绳子</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p>
<hr>
<h3 id="方法一：高数推导"><a href="#方法一：高数推导" class="headerlink" title="方法一：高数推导"></a>方法一：高数推导</h3><p><u><strong>由高数计算公式推导得出：1.当所有绳段长度相等时，乘积最大。2.最优的绳段长度为3。</strong></u></p>
<p><u><strong>那么就是用总绳长除3：余数位0则正好；余数为2则最后一段长度为2；余数为1则将一段长度为3的片段拿出来与1一起组成一个长度为4的片段。</strong></u></p>
<p><strong>时间复杂度：O(1)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//java中的^是位异或运算符，并不是幂运算符。</span></span><br><span class="line">            <span class="comment">//java中的幂运算要使用方法double Math.pow(double,double)</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,count);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,count)*<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,count - <span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-1"><a href="#方法二：动态规划-1" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><u><strong>比较少见的动态规划，每次计算一个状态值时，把前面的每一个状态值都用到了。</strong></u></p>
<p><u><strong>这种动态规划用法也一定要掌握。</strong></u></p>
<p><strong>思路：首先我们把一段长度为i绳子分成两段，一段长度为j，另一端长度为i-j：</strong></p>
<p><strong>那么会有四种情况：</strong></p>
<ol>
<li><strong>j和i-j都不能再拆了：dp[i]=j*(i-j);</strong></li>
<li><strong>j能拆，i-j不能拆：dp[i]=dp[j]*(i-j);</strong></li>
<li><strong>j不能拆，i-j能拆：dp[i]=j*dp[i-j];</strong></li>
<li><strong>j和i-j都能拆：dp[i]=dp[j]*dp[i-j];</strong></li>
</ol>
<p><strong>我们取上面4种情况的最大值即可，我们把它整理一下，得到递推公式如下：</strong></p>
<p><strong><code>dp[i] = max(dp[i], (max(j, dp[j])) * (max(i - j, dp[i - j])));</code></strong></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：一段长度为n的绳子能得到的最大乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化：</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分成最小的一段就是2，一般不考虑长度为1的分段。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(j,dp[j])*Math.max(i - j,dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题14-2-剪绳子2"><a href="#面试题14-2-剪绳子2" class="headerlink" title="面试题14_2.剪绳子2"></a>面试题14_2.剪绳子2</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p><strong>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</strong></p>
<p>示例 1：</p>
<blockquote>
<p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p>
<hr>
<h3 id="方法一：高数推导-1"><a href="#方法一：高数推导-1" class="headerlink" title="方法一：高数推导"></a>方法一：高数推导</h3><p>本题相比于<a href="https://littleforestjia.github.io/2021/01/01/%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9814_1.%E5%89%AA%E7%BB%B3%E5%AD%90/" target="_blank" rel="noopener">面试题14_1.剪绳子</a>其实就是增加了一个取模的条件，所以大致思路不变，只需改变计算细节，<strong><u>本质上变成了一道考察Interger、Long、Double数据类型取值范围的题目。</u></strong></p>
<p><strong><u>本题中要求每次乘3之后都要取模，所以不能直接用Math.pow方法直接一下求出double类型结果。但是int类型的取值范围为-2147483648~+2147483647，计算结果有可能直接在一次乘3之后直接溢出了，所以此处我们设置结果数据类型为long或者double，一次一次乘3的计算，每次乘3后都取模。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本题中要求每次乘3之后都要取模，所以不能直接用Math.pow方法直接一下求出double类型结果。</span></span><br><span class="line">        <span class="comment">//但是int类型的取值范围为-2147483648~+2147483647，计算结果有可能直接在一次乘3之后直接溢出了，</span></span><br><span class="line">        <span class="comment">//所以此处我们设置结果数据类型为long或者double，一次一次乘3的计算，每次乘3后都取模。</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                ans = ans * <span class="number">3</span> % p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                ans = ans * <span class="number">3</span> % p;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">2</span> % p;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                ans = ans * <span class="number">3</span> % p;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">2</span> % p;</span><br><span class="line">            ans = ans * <span class="number">2</span> % p;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题15-二进制中1的个数"><a href="#面试题15-二进制中1的个数" class="headerlink" title="面试题15.二进制中1的个数"></a>面试题15.二进制中1的个数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p>
<hr>
<h3 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p><u><strong>位与运算准则：</strong></u></p>
<ul>
<li><u><strong>n&amp;1=1，则n二进制最后一位为1；</strong></u></li>
</ul>
<ul>
<li><u><strong>n&amp;1=0，则n二进制最后一位为0。</strong></u></li>
</ul>
<p><strong><u>思路：将n与1进行为与运算，然后将n无符号右移一位。循环以上步骤，直到n为0。</u></strong></p>
<p><strong>时间复杂度：O(logn)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) count++;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java位运算之左移、右移与无符号右移"><a href="#java位运算之左移、右移与无符号右移" class="headerlink" title="java位运算之左移、右移与无符号右移"></a>java位运算之左移、右移与无符号右移</h3><ul>
<li><strong>&lt;&lt;：左移运算符：左操作数按位左移右操作数指定的位数。<u>移动得到的右边空位自动充零，注意包括符号位，也就是说左移运算符有可能改变一个数的正负。</u></strong></li>
<li><strong>&gt;&gt;：右移运算符：左操作数按位右移右操作数指定的位数。<u>移动得到的左边空位自动充零，但是表示符号的最高位除外，正数右移高位补0，负数右移高位补1。</u></strong></li>
<li><strong>&gt;&gt;&gt;：无符号右移运算符：左操作数按位右移右操作数指定的位数。<u>移动得到的左边空位自动充零，无论是正数还是负数，最高位通通补0。</u></strong></li>
</ul>
<h2 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16.数值的整数次方"></a>面试题16.数值的整数次方</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 2.10000, 3<br>输出: 9.26100</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2^(-2) = 1/(2^2) = 1/4 = 0.25</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p>
<hr>
<h3 id="方法一：递归-二分法"><a href="#方法一：递归-二分法" class="headerlink" title="方法一：递归+二分法"></a>方法一：递归+二分法</h3><p><strong><u>把递归简化一下：当n为正偶数时，myPow(double x, int n)==myPow(double x*x, int n/2)。</u></strong></p>
<p><strong>时间复杂度：O(logn)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> myPow(x * x,n / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x * myPow(x,n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (myPow(x,-n - <span class="number">1</span>) * x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17.打印从1到最大的n位数"></a>面试题17.打印从1到最大的n位数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: n = 1<br>输出: 1,2,3,4,5,6,7,8,9</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p>
<hr>
<h3 id="方法一：递归-2"><a href="#方法一：递归-2" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><u><strong>大数越界问题：无论是short、int、long…任意数字数据类型，数字的取值范围都是有限的，超出取值范围的数字无法正常存储。</strong></u></p>
<p><u><strong>解决方法：要从根本上解决大数越界问题，大数的表示应使用字符串String类型。</strong></u></p>
<p><strong><u>思路：先确定高位，再确定低位，从0到9，这样才能保证最后的结果字符串中数字是按升序排列。</u></strong></p>
<p><strong>时间复杂度：O(10^n)</strong></p>
<p><strong>空间复杂度：O(10^n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] answer = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        <span class="keyword">char</span>[] loop = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dfs(answer,ans,<span class="number">0</span>,n,loop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将ans最后的逗号删掉</span></span><br><span class="line">        ans.deleteCharAt(ans.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] answer,StringBuilder ans,<span class="keyword">int</span> index,<span class="keyword">int</span> n,<span class="keyword">char</span>[] loop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line">            ans.append(<span class="keyword">new</span> String(answer));</span><br><span class="line">            ans.append(<span class="string">','</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> num : loop) &#123;</span><br><span class="line">            answer[index] = num;</span><br><span class="line">            dfs(answer,ans,index + <span class="number">1</span>,n,loop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong><u>本题中的很多类型转换可以参考博文<a href="https://littleforestjia.github.io/2021/01/03/%E3%80%90%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0%E3%80%91_java%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2&%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/" target="_blank" rel="noopener">java数字的进制转换&amp;数据类型转化</a>。</u></strong></p>
<h2 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18.删除链表的节点"></a>面试题18.删除链表的节点</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p>
<hr>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode god = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        god.next = head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next.val == val) head.next = head.next.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> god.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题19-正则表达式匹配"><a href="#面试题19-正则表达式匹配" class="headerlink" title="面试题19.正则表达式匹配"></a>面试题19.正则表达式匹配</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现一个函数用来匹配包含’. ‘和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<blockquote>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入:<br>s = “ab”<br>p = “.*”<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个（’*‘）任意字符（’.’）。</p>
</blockquote>
<p>示例 4:</p>
<blockquote>
<p>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
</blockquote>
<p>示例 5:</p>
<blockquote>
<p>输入:<br>s = “mississippi”<br>p = “mis<em>is*p</em>.”<br>输出: false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p>
<hr>
<h3 id="方法一：递归-3"><a href="#方法一：递归-3" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong><u>因为*符号要和它前面的一个字母进行组合来进行匹配，所以我们从后往前来进行递归遍历。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(),n = p.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(n - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">//p字符串以*字符打头的情况</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m != <span class="number">0</span> &amp;&amp; (p.charAt(n - <span class="number">2</span>) == s.charAt(m - <span class="number">1</span>) || p.charAt(n - <span class="number">2</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这一步是该题递归的关键：第一种情况表示*组合不匹配该字符；第二种情况表示*组合匹配一个该字符，但*组合可以继续匹配。</span></span><br><span class="line">                <span class="comment">//一定要理解这两种情况就囊括了所有的情况，因为无论是匹配多少个连续相同的该字符，都是重复递归该句实现的。</span></span><br><span class="line">                <span class="comment">//比如*组合匹配一个字符，就是先第二种情况再第一种情况；匹配两个字符，就是先第二种情况再第二种情况最后第一种情况，依此类推。</span></span><br><span class="line">                <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>, m), p.substring(<span class="number">0</span>, n - <span class="number">2</span>)) || isMatch(s.substring(<span class="number">0</span>, m - <span class="number">1</span>), p.substring(<span class="number">0</span>, n));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//*符号前一个符号与s中该符号无法匹配的情况</span></span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>, m), p.substring(<span class="number">0</span>, n - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(n - <span class="number">1</span>) == <span class="string">'.'</span> || s.charAt(m - <span class="number">1</span>) == p.charAt(n - <span class="number">1</span>)) <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>,m - <span class="number">1</span>),p.substring(<span class="number">0</span>,n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划-2"><a href="#方法二：动态规划-2" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p><strong><u>见<a href="https://littleforestjia.github.io/2020/10/20/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/" target="_blank" rel="noopener">10.正则表达式匹配(非常重要)</a>此处不再复写，两种方法进行比较：整体思路是一样的，递归方法时间复杂度更大，空间复杂度更小，面试时更推荐使用动态规划。</u></strong></p>
<h2 id="面试题21-调整数组顺序使奇数位于偶数前面"><a href="#面试题21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21.调整数组顺序使奇数位于偶数前面"></a>面试题21.调整数组顺序使奇数位于偶数前面</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<blockquote>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p>
<hr>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22.链表中倒数第k个节点"></a>面试题22.链表中倒数第k个节点</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p>
<hr>
<h3 id="方法一：栈-1"><a href="#方法一：栈-1" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p><strong><u>很多数组和链表的题都可以用双指针啊，最主要是要计算处两个指针之间的数学关系，能使用双指针就尽量不要使用栈等其他数据结构。</u></strong></p>
<p><strong>前指针先走k步，然后同步前进，前指针走完链表时，后指针刚好到倒数第k个节点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24.反转链表"></a>面试题24.反转链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p>
<hr>
<h3 id="方法一：递归-4"><a href="#方法一：递归-4" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = temp.next;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        newHead.next = reverseList(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双指针-1"><a href="#方法二：双指针-1" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p><strong>双指针方法也就是迭代的方法，就是一个接一个地反转节点的指向，相比于递归方法，时间复杂度O(n)不变，空间复杂度从O(n)变成了O(1)，所以还是双指针方法更好。此处不再复写。</strong></p>
<h2 id="面试题25-合并两个排序的链表"><a href="#面试题25-合并两个排序的链表" class="headerlink" title="面试题25.合并两个排序的链表"></a>面试题25.合并两个排序的链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a></p>
<hr>
<h3 id="方法一：递归-5"><a href="#方法一：递归-5" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            ListNode head = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            head.next = mergeTwoLists(l1,l2);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode head = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            head.next = mergeTwoLists(l1,l2);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26.树的子结构"></a>面试题26.树的子结构</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<blockquote>
<pre><code> 3
/ \</code></pre><p>   4   5<br>  / <br> 1   2</p>
</blockquote>
<p>给定的树 B：</p>
<blockquote>
<p>   4<br>  /<br> 1</p>
</blockquote>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：A = [1,2,3], B = [3,1]<br>输出：false</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a></p>
<hr>
<h3 id="方法一：前序遍历-递归"><a href="#方法一：前序遍历-递归" class="headerlink" title="方法一：前序遍历+递归"></a>方法一：前序遍历+递归</h3><p><strong><u>这实现方法太巧妙了，要硬记。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于前序遍历的方法，递归地遍历A中每一个节点是否与B根节点的值相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) <span class="keyword">return</span> isEquel(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在A中找到与B根节点相等的节点之后，判断B是否可以完全对应上去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEquel</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (A.val == B.val) <span class="keyword">return</span> isEquel(A.left,B.left) &amp;&amp; isEquel(A.right,B.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27.二叉树的镜像"></a>面试题27.二叉树的镜像</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<blockquote>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9</p>
</blockquote>
<p>镜像输出：</p>
<blockquote>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
</blockquote>
<p>示例 1：</p>
<blockquote>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p>
<hr>
<h3 id="方法一：递归-6"><a href="#方法一：递归-6" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28.对称的二叉树"></a>面试题28.对称的二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<blockquote>
<pre><code>1</code></pre><p>   / <br>  2   2<br> / \ / <br>3  4 4  3</p>
</blockquote>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<blockquote>
<p>  1<br>   / <br>  2   2<br>   \   <br>   3    3</p>
</blockquote>
<p> 示例 1：</p>
<blockquote>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p>
<hr>
<h3 id="方法一：递归-7"><a href="#方法一：递归-7" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isEquel(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEquel</span><span class="params">(TreeNode left,TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isEquel(left.left,right.right) &amp;&amp; isEquel(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29.顺时针打印矩阵"></a>面试题29.顺时针打印矩阵</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
<hr>
<h3 id="方法一：按层模拟"><a href="#方法一：按层模拟" class="headerlink" title="方法一：按层模拟"></a>方法一：按层模拟</h3><p><u><strong>思路：把矩阵看成若干层，最先打印最外层，然后打印次外层…</strong></u></p>
<p><u><strong>定义矩阵中的第k层是由距离最近边界为k的顶点所组成的。</strong></u></p>
<p><strong>时间复杂度：O(m*n)</strong></p>
<p><strong>空间复杂度：O(1) //空间复杂度是指除了返回值以外，额外使用的内存空间。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>,top = <span class="number">0</span>,bottum = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处这个循环条件是本题的关键，这个循环条件一定要记住。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottum) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left;i &lt;= right;i++) &#123;</span><br><span class="line">                ans[count] = matrix[top][i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottum; i++) &#123;</span><br><span class="line">                ans[count] = matrix[i][right];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//必须要在该层能围成一个圈的时候，才能接着遍历下边和左边，否则根本就没有下边和左边，会导致上边和右边遍历两次。</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottum) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>;i &gt;= left;i--) &#123;</span><br><span class="line">                    ans[count] = matrix[bottum][i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottum - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    ans[count] = matrix[i][left];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题30-包含min函数的栈"><a href="#面试题30-包含min函数的栈" class="headerlink" title="面试题30.包含min函数的栈"></a>面试题30.包含min函数的栈</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的<strong><u>时间复杂度都是 O(1)</u></strong>。</p>
<p>示例:</p>
<blockquote>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a></p>
<hr>
<h3 id="方法一：双栈-1"><a href="#方法一：双栈-1" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h3><p><strong><u>思路：本题的关键在于，每删除一个最小元素时，所记录的最小元素能退回到原来所记录的最小元素，也就是说需要一个辅助栈，其长度与主栈一直相同，记录主栈在每个时刻的最小元素。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; mainStack;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.helpStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.helpStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.helpStack.push(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.helpStack.push(<span class="keyword">this</span>.helpStack.peek() &gt; x ? x : <span class="keyword">this</span>.helpStack.peek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainStack.pop();</span><br><span class="line">        <span class="keyword">this</span>.helpStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.helpStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题31-栈的压入弹出序列"><a href="#面试题31-栈的压入弹出序列" class="headerlink" title="面试题31.栈的压入弹出序列"></a>面试题31.栈的压入弹出序列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<strong>假设压入栈的所有数字均不相等。</strong>例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
<hr>
<h3 id="方法一：辅助栈"><a href="#方法一：辅助栈" class="headerlink" title="方法一：辅助栈"></a>方法一：辅助栈</h3><p><u><strong>这道题也属于一个巧思，需要硬记。</strong></u></p>
<p><u><strong>思路：就是创建一个辅助栈来真正模拟该栈，将入栈队列依次压入栈中，每压入一个元素，检验出栈队列是否需要将栈顶元素出栈。若执行完上述操作之后，辅助栈正好为空，说明此出栈队列可以对应上入栈队列。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[count]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题32-1-从上到下打印二叉树"><a href="#面试题32-1-从上到下打印二叉树" class="headerlink" title="面试题32_1.从上到下打印二叉树"></a>面试题32_1.从上到下打印二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<p>​     3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>返回：</p>
<blockquote>
<p>[3,9,20,15,7]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</a></p>
<hr>
<h3 id="方法一：队列"><a href="#方法一：队列" class="headerlink" title="方法一：队列"></a>方法一：队列</h3><p>嘿嘿，小爷早就总结了二叉树的各种非递归遍历方法，思路见博文<a href="https://littleforestjia.github.io/2021/01/04/%E3%80%90%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0%E3%80%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">二叉树的非递归遍历方法</a>。</p>
<p><strong><u>Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中的队列一般使用链表来实现。</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            answer.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[answer.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; answer.size(); i++) &#123;</span><br><span class="line">            ans[i] = answer.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题32-2-从上到下打印二叉树2"><a href="#面试题32-2-从上到下打印二叉树2" class="headerlink" title="面试题32_2.从上到下打印二叉树2"></a>面试题32_2.从上到下打印二叉树2</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p> 例如:</p>
<p>给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<p>3</p>
<p>/ <br>9  20<br> /  <br>15   7</p>
</blockquote>
<p>返回其层次遍历结果：</p>
<blockquote>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</a></p>
<hr>
<h3 id="方法一：队列-1"><a href="#方法一：队列-1" class="headerlink" title="方法一：队列"></a>方法一：队列</h3><p>嘿嘿，小爷早就总结了二叉树的各种非递归遍历方法，思路见博文<a href="https://littleforestjia.github.io/2021/01/04/%E3%80%90%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0%E3%80%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">二叉树的非递归遍历方法</a>。</p>
<p><strong><u>思路：可以发现，每当遍历完一层的二叉树节点时，这时队列中的元素正好是下一层中的所有节点。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; subAns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> rowSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                subAns.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(subAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题32-3-从上到下打印二叉树3"><a href="#面试题32-3-从上到下打印二叉树3" class="headerlink" title="面试题32_3.从上到下打印二叉树3"></a>面试题32_3.从上到下打印二叉树3</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:</p>
<p>给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<p>3</p>
<p> / <br>9  20<br>  /  <br> 15   7</p>
</blockquote>
<p>返回其层次遍历结果：</p>
<blockquote>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof</a></p>
<hr>
<h3 id="方法一：队列-双端链表"><a href="#方法一：队列-双端链表" class="headerlink" title="方法一：队列+双端链表"></a>方法一：队列+双端链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当方法声明返回值类型为List时，返回List、ArrayList和LinkedList类型的数据都可以，不会报错。</span></span><br><span class="line">            LinkedList&lt;Integer&gt; subAns = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rowSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//addFirst()方法就是在链表头部添加元素。</span></span><br><span class="line">                <span class="keyword">if</span> (flag) subAns.addFirst(root.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//addLast()方法就是在链表尾部添加元素，与add()方法作用相同。</span></span><br><span class="line">                <span class="keyword">else</span> subAns.addLast(root.val);</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) queue.offer(root.left);</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) queue.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(subAns);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双端队列-链表"><a href="#方法二：双端队列-链表" class="headerlink" title="方法二：双端队列+链表"></a>方法二：双端队列+链表</h3><p><strong>同理也可以利用双端队列的属性，代码不再复写。</strong></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><u><strong>java中的LinkedList数据结构具有双向链表的属性，所以可以用它具有addFirst()和addLast()方法分别可以向数组两端添加元素，具有removeFirst()和removeLast()分别向数组两端删除元素。</strong></u></p>
<p><u><strong>其中，addFirst()方法就是在链表头部添加元素。addLast()方法就是在链表尾部添加元素，与add()方法作用相同。</strong></u></p>
<p><u><strong>由LinkedList实现的队列Queue自然也具有双端队列的属性，也具有上述的四个方法。</strong></u></p>
</li>
<li><p><u><strong>当方法声明返回值类型为List时，返回List、ArrayList和LinkedList类型的数据都可以，不会报错。</strong></u></p>
</li>
</ul>
<h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33.二叉搜索树的后序遍历序列"></a>面试题33.二叉搜索树的后序遍历序列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p> 参考以下这颗二叉搜索树：</p>
<blockquote>
<p>​     5<br>    / \</p>
<p>   2   6<br>  / <br> 1   3</p>
</blockquote>
<p>示例 1：</p>
<blockquote>
<p>输入: [1,6,3,2,5]<br>输出: false</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: [1,3,2,6,5]<br>输出: true</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</a></p>
<hr>
<h3 id="方法一：递归-8"><a href="#方法一：递归-8" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong><u>思路：一个二叉搜索树的后序遍历结果的格式一定是{小于根节点的节点，大于根节点的节点，根节点}</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = postorder.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (postorder[length - <span class="number">1</span>] &gt; postorder[count]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &lt; postorder[length - <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于根节点的节点所组成的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            left[i] = postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于根节点的节点所组成的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[length - <span class="number">1</span> - count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span> - count; i++) &#123;</span><br><span class="line">            right[i] = postorder[i + count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verifyPostorder(left) &amp;&amp; verifyPostorder(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：官方答案"><a href="#方法二：官方答案" class="headerlink" title="方法二：官方答案"></a>方法二：官方答案</h3><p><strong>注意官方答案与我自己写的代码的主要区别，明显<u>我自己写的代码空间复杂度更大且可读性更差</u>。因为<u>每次递归我都在原输入数组的基础之上截取一部分连续元素作为下一层递归方法的输入数组</u>，其实这样没有必要。</strong></p>
<p><strong>以后遇到这种情况都学习该官方答案中的写法：<u>创建一个新的递归方法，该方法的输入参数为数组、截取起始点和截取终止点，每层递归都使用同一个数组作为输入</u>，只不过截取部分不一样。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题34-二叉树中和为某一值的路径"><a href="#面试题34-二叉树中和为某一值的路径" class="headerlink" title="面试题34.二叉树中和为某一值的路径"></a>面试题34.二叉树中和为某一值的路径</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p> 示例:</p>
<p>给定如下二叉树，以及目标和 sum = 22，</p>
<blockquote>
<p>​          5<br>         / <br>        4   8<br>       /   / <br>      11  13  4<br>     /  \    / <br>    7    2  5   1</p>
</blockquote>
<p>返回:</p>
<blockquote>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p>
<hr>
<h3 id="方法一：递归回溯法-1"><a href="#方法一：递归回溯法-1" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> answers;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path(root,sum,answers,temp);</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,List&lt;List&lt;Integer&gt;&gt; answers,List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意一定要到达叶子节点时才算做一条路径</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right ==<span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.add(root.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意这里一定要新建一个链表加到最终返回链表中，如果直接把临时链表temp加到最终返回链表中，</span></span><br><span class="line">            <span class="comment">//则最终返回链表中的元素指向的其实就是一直在改变的temp。</span></span><br><span class="line">            List&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;(temp);</span><br><span class="line"></span><br><span class="line">            answers.add(answer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意节点有可能是负值，所以每条路径都要查询到最深处才能确定这条路径的节点值之和等不等于sum</span></span><br><span class="line">            temp.add(root.val);</span><br><span class="line">            path(root.left,sum - root.val,answers,temp);</span><br><span class="line">            path(root.right,sum - root.val,answers,temp);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题35-复杂链表的复制"><a href="#面试题35-复杂链表的复制" class="headerlink" title="面试题35.复杂链表的复制"></a>面试题35.复杂链表的复制</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 </p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p>
<hr>
<h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用hashMap记录每个节点与复制节点作为一个键值对，</span></span><br><span class="line">        <span class="comment">//方便第二次遍历时为复制链表的节点添加random属性时直接找到复制链表中的对应节点。</span></span><br><span class="line">        HashMap&lt;Node,Node&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原链表哑节点</span></span><br><span class="line">        Node temp = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        temp.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制链表哑节点</span></span><br><span class="line">        Node copyTemp = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node current = copyTemp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次遍历，按照next属性创建好初步的复制链表</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">            hashMap.put(head,node);</span><br><span class="line"></span><br><span class="line">            current.next = node;</span><br><span class="line">            current = current.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次遍历，完善复制链表中每个节点的random属性</span></span><br><span class="line">        head = temp.next;</span><br><span class="line">        current = copyTemp.next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current.random = hashMap.get(head.random);</span><br><span class="line">            head = head.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyTemp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：拼接与拆分"><a href="#方法二：拼接与拆分" class="headerlink" title="方法二：拼接与拆分"></a>方法二：拼接与拆分</h3><p><strong>这种方法相比于方法一减小了空间复杂度，只使用了常数级内存空间，具体实现代码不再复写。</strong></p>
<h2 id="面试题36-二叉搜索树与双向链表"><a href="#面试题36-二叉搜索树与双向链表" class="headerlink" title="面试题36.二叉搜索树与双向链表"></a>面试题36.二叉搜索树与双向链表</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p> 为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p> <img src="//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9836.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5C1.jpeg" alt></p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p>  <img src="//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/E:%5CBlogs%5CMyHexoBlogs%5Cmyblogs%5Csource_posts%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9836.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5C2.jpeg" alt></p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</a></p>
<hr>
<h3 id="方法一：递归中序遍历"><a href="#方法一：递归中序遍历" class="headerlink" title="方法一：递归中序遍历"></a>方法一：递归中序遍历</h3><p><strong><u>非递归的中序遍历和后序遍历代码写起来本来就比较麻烦，就算是最简单的前序遍历的非递归代码写起来也比递归代码要麻烦的多。所以非递归一时比较难想，而且要结合别的操作的情况下，还是用递归方法来对二叉树进行前中后序遍历比较好。</u></strong></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归方法时，多用且善用全局变量，很多时候不能用局部变量代替全局变量，比如本题中这两个全局变量。</span></span><br><span class="line">    <span class="comment">//pre为前驱节点，head为哑节点。</span></span><br><span class="line">    Node pre;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        pre.right = head.right;</span><br><span class="line">        head.right.left = pre;</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法，全局变量pre用于使不同层次递归方法中被遍历的节点之间进行交流，非常重要。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历左子树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//重要：pre会在本次访问之前先在递归方法中被改变，</span></span><br><span class="line">        <span class="comment">//所以在本次访问中使用到的pre是已经经过了很多次递归方法修改之后返回来的pre。</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 访问本节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果pre已经赋上值了，说明本次访问的节点具有前驱节点；</span></span><br><span class="line">        <span class="comment">//如果没有赋值，则说明本次访问的节点为头结点。</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.right = root;</span><br><span class="line">        <span class="keyword">else</span> head.right = root;</span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历右子树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题37-序列化二叉树"><a href="#面试题37-序列化二叉树" class="headerlink" title="面试题37.序列化二叉树"></a>面试题37.序列化二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>示例: </p>
<blockquote>
<p>你可以将以下二叉树：<br>​    1</p>
<p>   / <br>  2   3<br>     / <br>    4   5</p>
<p>序列化为 “[1,2,3,null,null,4,5]”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof</a></p>
<hr>
<h3 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h3><p><strong>总体思路：通常使用的前序、中序、后序、层序遍历记录的二叉树的信息不完整，即唯一的输出序列可能对应着多种二叉树可能性。<u>题目要求的序列化和反序列化是可逆操作。因此，序列化的字符串应携带完整的二叉树信息，使其所表示的二叉树是唯一确定的。</u></strong></p>
<p><strong>序列化思路：为完整表示二叉树，考虑将叶节点下的null也记录。在此基础上，对于列表中任意某节点node，其左子节点node.left和右子节点node.right在序列中的位置都是唯一确定的。也就是说<u>只要把二叉树中度为0和1的节点都补上值为null的辅助空子节点，得到的层序遍历结果就可以与一棵唯一的二叉树对应。</u></strong></p>
<p><strong>反序列化思路：查看具体实现代码。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉树序列化为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            root = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans.append(root.val);</span><br><span class="line">                queue.offer(root.left);</span><br><span class="line">                queue.offer(root.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> ans.append(<span class="string">"null"</span>);</span><br><span class="line">            ans.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.deleteCharAt(ans.length() - <span class="number">1</span>);</span><br><span class="line">        ans.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串反序列化为二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">"[]"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：String.split("*")方法可以将字符串以*字符参数为分隔符，分割成一个字符串数组。</span></span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>,data.length() - <span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        TreeNode head = root;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//每次将队列queue中的一个节点取出，这时数组中对应的下两个值vals[i]和vals[i+1]就正好是该节点的左右子节点的值。</span></span><br><span class="line">            root = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!vals[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">                root.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.offer(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!vals[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">                root.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><strong><u>二叉树层序遍历就是最典型的广度优先搜索(BFS)。</u></strong></p>
<h2 id="面试题38-字符串的排列"><a href="#面试题38-字符串的排列" class="headerlink" title="面试题38.字符串的排列"></a>面试题38.字符串的排列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<blockquote>
<p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
<hr>
<h3 id="方法一：递归回溯-剪枝"><a href="#方法一：递归回溯-剪枝" class="headerlink" title="方法一：递归回溯+剪枝"></a>方法一：递归回溯+剪枝</h3><p><strong><u>本题的关键时在递归回溯的基础之上去除重复。</u></strong></p>
<p><strong><u>思路：要解决重复问题，我们只要设定一个规则，保证在填第i个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中从左往右第一个未被填过的数字。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符进行排序，使得相同字符连续放置，这样在判断数组中是否具有相同元素时，只需要与相邻字符比较即可。</span></span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该数组用来标记chars数组中那个字符已经被使用过了，则在后面的递归中不能再使用该字符。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(chars,mark,<span class="number">0</span>,sb,ans);</span><br><span class="line">        String[] answers = <span class="keyword">new</span> String[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            answers[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">boolean</span>[] mark,<span class="keyword">int</span> index,StringBuilder sb,List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == chars.length) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有被使用并且(和前一个字符不同或者前一个相同字符已经使用了)的字符，才会被考虑添加到字符串上。</span></span><br><span class="line">            <span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !mark[i - <span class="number">1</span>] &amp;&amp; chars[i] == chars[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                mark[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(chars[i]);</span><br><span class="line">                dfs(chars,mark,index + <span class="number">1</span>,sb,ans);</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                mark[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题39-数组中出现次数超过一半的数字"><a href="#面试题39-数组中出现次数超过一半的数字" class="headerlink" title="面试题39.数组中出现次数超过一半的数字"></a>面试题39.数组中出现次数超过一半的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：中位数"><a href="#方法一：中位数" class="headerlink" title="方法一：中位数"></a>方法一：中位数</h3><p><strong>先排序，再找中位数，数组中位数一定是出现次数超过一半的那个数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：摩尔投票法"><a href="#方法二：摩尔投票法" class="headerlink" title="方法二：摩尔投票法"></a>方法二：摩尔投票法</h3><p><strong><u>这是巧思，得硬记。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>,votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每个元素有一次投票的机会，只能投一个元素，相同的投赞成，不同的投反对，</span></span><br><span class="line">            <span class="comment">//一旦一个元素票数到0就换被投票的人，最后得到的一定是出现次数超过一半的元素。</span></span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;</span><br><span class="line">            <span class="keyword">if</span> (num == x) votes++;</span><br><span class="line">            <span class="keyword">else</span> votes--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40.最小的k个数"></a>面试题40.最小的k个数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof</a></p>
<hr>
<h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p><u><strong>时间复杂度：O(nlogn)</strong></u></p>
<p><u><strong>空间复杂度：O(logn)(此处主要是Array.sort()方法所需要的额外内存空间)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：堆排序"><a href="#方法二：堆排序" class="headerlink" title="方法二：堆排序"></a>方法二：堆排序</h3><p><strong>堆就是专门设计出来解决topk问题的，也就是专门设计出来寻找一个具有可比较元素的数组的前k大的元素或者前k小的元素。本题中堆排序优于快速排序。</strong></p>
<p><strong><u>java中主要使用工具类中的PriorityQueue来作为二叉堆的底层实现，主要有offer、poll、peek三个方法。</u></strong></p>
<p><strong>思路：先将数组中前k个元素放入二叉大根堆中，然后遍历剩下的元素，若元素小于堆顶元素则删除堆顶元素再将该元素添加到二叉大根堆中。</strong></p>
<p><u><strong>时间复杂度：O(nlogk)</strong></u></p>
<p><u><strong>空间复杂度：O(logk)</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java中使用输入了比较器参数的优先级队列作为二叉堆的底层实现。</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注意此处比较器方法的复写决定了该队列实现的是大根堆还是小根堆，</span></span><br><span class="line">                <span class="comment">//第二个参数减第一个参数表示逆序排序，也就是大的值放在上面，小的值放在下面，表示该队列实现的是大根堆。</span></span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            queue.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; queue.peek()) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            ans[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：快速排序"><a href="#方法三：快速排序" class="headerlink" title="方法三：快速排序"></a>方法三：快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.length &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原地不断划分数组</span></span><br><span class="line">        partitionArray(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 做一次 partition 操作</span></span><br><span class="line">        <span class="keyword">int</span> m = partition(arr, lo, hi);</span><br><span class="line">        <span class="comment">// 此时数组前 m 个数，就是最小的 m 个数</span></span><br><span class="line">        <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">            <span class="comment">// 正好找到最小的 k(m) 个数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">            <span class="comment">// 最小的 k 个数一定在前 m 个数中，递归划分</span></span><br><span class="line">            partitionArray(arr, lo, m-<span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在右侧数组中寻找最小的 k-m 个数</span></span><br><span class="line">            partitionArray(arr, m+<span class="number">1</span>, hi, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partition 函数和快速排序中相同，具体可参考快速排序相关的资料</span></span><br><span class="line">    <span class="comment">// 代码参考 Sedgewick 的《算法4》</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, lo, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><strong>堆排序相对来说是大多数情况下的最优选。</strong></p>
<h2 id="面试题41-数据流中的中位数"><a href="#面试题41-数据流中的中位数" class="headerlink" title="面试题41.数据流中的中位数"></a>面试题41.数据流中的中位数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<p>示例 1：</p>
<blockquote>
<p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof</a></p>
<hr>
<h3 id="方法一：二叉堆-优先队列"><a href="#方法一：二叉堆-优先队列" class="headerlink" title="方法一：二叉堆/优先队列"></a>方法一：二叉堆/优先队列</h3><p><strong><u>思路：创建两个二叉堆，第一个存放数据流中较小的一半数据，第二个存放数据流中较大的一半数据。</u></strong></p>
<p><strong>时间复杂度：</strong></p>
<ul>
<li><strong>查找中位数 O(1)： 获取堆顶元素使用 O(1) 时间；</strong></li>
<li><strong>添加数字 O(log N)： <u>堆(优先队列)的插入和弹出操作使用 O(logN) 时间</u>。</strong></li>
</ul>
<p><strong>空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">//我的设想是：当数据总数为偶数时，两堆中存放数据量相同；当数据总数为奇数时，small堆中存放数据比large堆中多一个。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        <span class="keyword">this</span>.small = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//大根堆</span></span><br><span class="line">        <span class="keyword">this</span>.large = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据时，如果数据总数为偶数，则先将数据放入large中，再将large的栈顶元素弹出放入small中；</span></span><br><span class="line">    <span class="comment">//如果数据总数为奇数，则先将数据放入small中，在将small的栈顶元素弹出放入large中。</span></span><br><span class="line">    <span class="comment">//这样是为了确保新添加进来的数据和数据流中的每个数据都进行了比较。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">double</span>)(small.peek() + large.peek())/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>)small.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42.连续子数组的最大和"></a>面试题42.连续子数组的最大和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p>示例1:</p>
<blockquote>
<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-2"><a href="#方法一：动态规划-2" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong>与题目<a href="https://littleforestjia.github.io/2020/11/08/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" target="_blank" rel="noopener">【力扣刷题】_53.最大子序和</a>相同。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：表示以第i个数字为尾端的子数组的最大子数组和。</span></span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum = Math.max(nums[i],sum + nums[i]);</span><br><span class="line">            maxSum = Math.max(sum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题43-前n个整数中1出现的次数"><a href="#面试题43-前n个整数中1出现的次数" class="headerlink" title="面试题43.前n个整数中1出现的次数"></a>面试题43.前n个整数中1出现的次数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 12<br>输出：5</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 13<br>输出：6</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</a></p>
<hr>
<h3 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h3><p><u><strong>巧思，需要硬记。</strong></u></p>
<p><u><strong>思路：将1~n中个位、十位、百位…中1出现的次数相加，即为1出现的总次数。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//hig记录高位值，curr记录当前位值，low记录低位值，count用来得到三个部分，ans表示该方法返回的答案。</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || curr != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当要计算某一位上1出现的次数时，将n分成三部分：高位、当前位、低位。</span></span><br><span class="line">            <span class="comment">//计算当前位上1出现的次数主要考虑高位-1和高位固定的情况：</span></span><br><span class="line">            <span class="comment">//高位-1的情况下，当前位和低位可以为任意值；</span></span><br><span class="line">            <span class="comment">//高位固定的情况下，当前位和低位连起来只能为更小的值。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="number">0</span>) ans = ans + high * count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (curr == <span class="number">1</span>) ans = ans + high * count + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans = ans + (high + <span class="number">1</span>) * count;</span><br><span class="line">            low = low + curr * count;</span><br><span class="line">            curr = high % <span class="number">10</span>;</span><br><span class="line">            high = high / <span class="number">10</span>;</span><br><span class="line">            count = count * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题44-数字序列中某一位的数字"><a href="#面试题44-数字序列中某一位的数字" class="headerlink" title="面试题44.数字序列中某一位的数字"></a>面试题44.数字序列中某一位的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p> 示例 1：</p>
<blockquote>
<p>输入：n = 3<br>输出：3</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 11<br>输出：0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：找规律"><a href="#方法一：找规律" class="headerlink" title="方法一：找规律"></a>方法一：找规律</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路：观察总结发现该序列中数字0<del>9占据了序列的9位，数字10</del>99占据了序列的90*2位，数字100~999占据了序列的900*3位…</strong></u></p>
<ul>
<li><u><strong>我们首先要判断第n位所在数字处于上述的哪一段中；</strong></u></li>
<li><u><strong>然后判断出第n位所在数字是该段中的第几个数字，即可确定该数字的数值；</strong></u></li>
<li><u><strong>然后确定第n位是该数字上的第几位。</strong></u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">long</span> temp = digit * count;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; temp) &#123;</span><br><span class="line">            n = (<span class="keyword">int</span>) (n - temp);</span><br><span class="line">            count++;</span><br><span class="line">            digit = digit * <span class="number">10</span>;</span><br><span class="line">            temp = digit * count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列中第n位所在数字所处段的前面有多少个数字。</span></span><br><span class="line">        temp = temp / <span class="number">9</span> / count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列中第n位所在数字</span></span><br><span class="line">        <span class="keyword">long</span> num = (n - <span class="number">1</span>) / count + temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第n位在该数字中的位置索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) % count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt(index) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题45-把数组排成最小的数"><a href="#面试题45-把数组排成最小的数" class="headerlink" title="面试题45.把数组排成最小的数"></a>面试题45.把数组排成最小的数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [10,2]<br>输出: “102”</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [3,30,34,5,9]<br>输出: “3033459”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p>
<hr>
<h3 id="方法一：快速排序"><a href="#方法一：快速排序" class="headerlink" title="方法一：快速排序"></a>方法一：快速排序</h3><p><strong><u>这道题本质上是一个排序问题，排序规则为：取出任意两个元素a和b，如果ab小于ba则应该将a放在b前面。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            strings[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(strings,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sb.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序方法，其思路是以strings[left]为轴点元素，使用双指针分别从两端开始找，每次找到左指针大于轴点、右指针小于轴点时，</span></span><br><span class="line">    <span class="comment">//交换左右指针元素，知道两指针相遇，这时两指针指向的点会是最右端的小于或等于轴点的元素，</span></span><br><span class="line">    <span class="comment">//此时这段数组的布局：轴点|不大于轴点的元素|不小于轴点的元素。然后我们交换轴点元素和指针元素，再对两段子数组递归快速排序方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] strings,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件：数组中元素小于两个。</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left,j = right;</span><br><span class="line">        String temp = strings[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((strings[j] + strings[left]).compareTo(strings[left] + strings[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> ((strings[i] + strings[left]).compareTo(strings[left] + strings[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            temp = strings[i];</span><br><span class="line">            strings[i] = strings[j];</span><br><span class="line">            strings[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        strings[i] = strings[left];</span><br><span class="line">        strings[left] = temp;</span><br><span class="line">        quickSort(strings,left,i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strings,i + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用JDK工具类排序"><a href="#方法二：使用JDK工具类排序" class="headerlink" title="方法二：使用JDK工具类排序"></a>方法二：使用JDK工具类排序</h3><p><strong>比较器Comparator的使用见博文<a href="https://littleforestjia.github.io/2021/01/08/%E3%80%90%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0%E3%80%91_%E6%AF%94%E8%BE%83%E5%99%A8Comparable%E5%92%8CComparator/" target="_blank" rel="noopener">【随手小记】_比较器Comparable和Comparator</a>。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            strings[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sb.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46.把数字翻译成字符串"></a>面试题46.把数字翻译成字符串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-3"><a href="#方法一：动态规划-3" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：前i位的不同翻译的种数</span></span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> dp1;</span><br><span class="line">        <span class="keyword">int</span> dp2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要注意两位数中的00~09并不能翻译成字符串</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(s.substring(<span class="number">0</span>,<span class="number">2</span>)) &lt;= <span class="number">25</span> &amp;&amp; Integer.parseInt(s.substring(<span class="number">0</span>,<span class="number">2</span>)) &gt;= <span class="number">10</span>) dp2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = dp2;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(s.substring(i - <span class="number">2</span>,i)) &lt;= <span class="number">25</span> &amp;&amp; Integer.parseInt(s.substring(i - <span class="number">2</span>,i)) &gt;= <span class="number">10</span>) sum = dp1 + dp2;</span><br><span class="line">            <span class="keyword">else</span> sum = dp2;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题47-礼物的最大价值"><a href="#面试题47-礼物的最大价值" class="headerlink" title="面试题47.礼物的最大价值"></a>面试题47.礼物的最大价值</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:</p>
<p>输入: </p>
<blockquote>
<p>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-4"><a href="#方法一：动态规划-4" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>这是一个路径问题，是一个很典型的动态规划问题，一般看到路径问题首先就要想到动态规划。</u></strong></p>
<p><strong>优化思路：反正原矩阵中的元素只需要在计算该格状态时使用一次，所以直接在原矩阵的格子中记录状态。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                grid[i][j] = Math.max(grid[i - <span class="number">1</span>][j],grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题48-最长不含重复字符的子字符串"><a href="#面试题48-最长不含重复字符的子字符串" class="headerlink" title="面试题48.最长不含重复字符的子字符串"></a>面试题48.最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<hr>
<h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>用左右指针组成一个滑动窗口，窗口中无重复字符则右指针右移，窗口中有重复字符则左指针右移，记录窗口的历史最大长度。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (set.contains(temp)) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(temp);</span><br><span class="line">            ans = Math.max(ans,set.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题49-丑数"><a href="#面试题49-丑数" class="headerlink" title="面试题49.丑数"></a>面试题49.丑数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<blockquote>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-5"><a href="#方法一：动态规划-5" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong><u>巧思题，要硬记。这样用动态规划，这谁想得到啊。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>,c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i]表示第i+1个丑数的值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个状态转移方程的过程非常精彩，整个过程就是每次把乘2、3、5的结果进行比较，</span></span><br><span class="line">            <span class="comment">//最小的放入队列中，另外两个待定，已经放入数组的再乘刚才那个值。</span></span><br><span class="line">            <span class="comment">//同时又通过索引能保证每个数都乘过2、3、5，都进行过比较，很妙，你让我自己想我绝对想不出来。</span></span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>,n3 = dp[b] * <span class="number">3</span>,n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2,n3),n5);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题50-第一个只出现一次的字符"><a href="#面试题50-第一个只出现一次的字符" class="headerlink" title="面试题50.第一个只出现一次的字符"></a>面试题50.第一个只出现一次的字符</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例:</p>
<blockquote>
<p>s = “abaccdeff”<br>返回 “b”</p>
</blockquote>
<blockquote>
<p>s = “”<br>返回 “ “</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a></p>
<hr>
<h3 id="方法一：HashMap"><a href="#方法一：HashMap" class="headerlink" title="方法一：HashMap"></a>方法一：HashMap</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路：遍历两遍，第一遍用来检查每个字符是否重复出现；第二遍用来拿出第一个不重复的字符。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重要：哈希表是去重的，存入已经存在的key时，会覆盖原键值对。</span></span><br><span class="line">                map.put(temp,-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> map.put(temp,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：哈希表中的键值对是无序的，所以无法直接遍历哈希表中的键值对，必须通过字符串来辅助遍历哈希表。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>) <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><u><strong>哈希表是去重的，存入已经存在的key时，会覆盖原键值对。</strong></u></li>
<li><u><strong>哈希表中的键值对是无序的，所以无法直接遍历哈希表中的键值对，必须通过其他数据来辅助遍历哈希表。</strong></u></li>
</ul>
<h2 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51.数组中的逆序对"></a>面试题51.数组中的逆序对</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,5,6,4]<br>输出: 5</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a></p>
<hr>
<h3 id="方法一：归并排序"><a href="#方法一：归并排序" class="headerlink" title="方法一：归并排序"></a>方法一：归并排序</h3><p><strong><u>巧思题，要硬记。这谁想得到啊！</u></strong></p>
<p><strong>该题的本质实际上是一个排序问题，六种比较排序中平均时间复杂度最小的就是归并和堆排序，而不借助工具类的就是归并排序了。</strong></p>
<p><strong>所以我们在归并排序的基础之上进行修改，计算逆序对数量。</strong></p>
<p><strong>时间复杂度：O(nlogn)（和归并排序相同）</strong></p>
<p><strong>空间复杂度：O(n)（和归并排序相同）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//归并排序需要一个与原数组等大的数组来辅助排序过程中的合并。</span></span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sort(nums,<span class="number">0</span>,n - <span class="number">1</span>,help);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序方法，返回值为被排序的这段数组中的逆序对的个数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] help)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a为排序数组的前半段中逆序对个数，b为后半段中逆序对个数。</span></span><br><span class="line">        <span class="keyword">int</span> a = sort(nums,left,mid,help);</span><br><span class="line">        <span class="keyword">int</span> b = sort(nums,mid + <span class="number">1</span>,right,help);</span><br><span class="line">        <span class="comment">//count为前半段元素与后半段元素共同参与组成的逆序对的个数，也是本层递归排序方法中要扭转的逆序对个数。</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = left,n = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将已经排好序的left~mid和mid+1~right这两段数组合并，先用辅助数组保存原来的数值序列，然后谁小谁先加到原数组上去。</span></span><br><span class="line">        <span class="comment">//m索引表示left~mid段中的元素，n索引表示mid+1~right段中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            help[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; mid) &#123;<span class="comment">//left~mid段中的元素已经全部按顺序添加到原数组上去了的情况</span></span><br><span class="line">                nums[i] = help[n];</span><br><span class="line">                n++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n &gt; right) &#123;<span class="comment">//mid+1~right段中的元素已经全部按顺序添加到原数组上去了的情况</span></span><br><span class="line">                nums[i] = help[m];</span><br><span class="line">                m++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (help[m] &lt;= help[n]) &#123;</span><br><span class="line">                nums[i] = help[m];</span><br><span class="line">                m++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = help[n];</span><br><span class="line">                n++;</span><br><span class="line">                <span class="comment">//只有在把后半段元素放到前半段元素之前的情况时，才会又逆序对被逆转。</span></span><br><span class="line">                count = count + mid + <span class="number">1</span> - m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count + a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52.两个链表的第一个公共节点"></a>面试题52.两个链表的第一个公共节点</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>示例 1：</p>
<p><img src="//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/1.png" alt></p>
<blockquote>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
</blockquote>
<p>示例 2：</p>
<p><img src="//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/2.png" alt></p>
<blockquote>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
</blockquote>
<p>示例 3：</p>
<p><img src="//littleforestjia.github.io/2020/11/06/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_%E5%89%91%E6%8C%87offer68%E9%A2%98/Blogs/MyHexoBlogs/myblogs/source/_posts/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/3.png" alt></p>
<blockquote>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>
<hr>
<h3 id="方法一：双指针-1"><a href="#方法一：双指针-1" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><u><strong>巧思题。</strong></u></p>
<p><u><strong>思路：两个指针分别从headA和headB出发，同速前进，任何一个指针走到链表尾部则跳转指向另一个链表头部，最后两指针会在第一个公共节点相遇。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = headA,b = headB;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                a = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a = a.next;</span><br><span class="line">            <span class="keyword">if</span> (b.next == <span class="keyword">null</span>) b = headA;</span><br><span class="line">            <span class="keyword">else</span> b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题53-1-在排序数组中查找数字"><a href="#面试题53-1-在排序数组中查找数字" class="headerlink" title="面试题53_1.在排序数组中查找数字"></a>面试题53_1.在排序数组中查找数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h3><p><strong>思路：其实这道题是相当于二分查找两个元素，起始点和终止点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找起始点</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组中没有target值得情况</span></span><br><span class="line">        <span class="keyword">if</span> (target != nums[left]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> begin = left;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找终止点</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题53-2-前n个数中缺失的数字"><a href="#面试题53-2-前n个数中缺失的数字" class="headerlink" title="面试题53_2.前n个数中缺失的数字"></a>面试题53_2.前n个数中缺失的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [0,1,3]<br>输出: 2</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：二分查找-1"><a href="#方法一：二分查找-1" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h3><p><strong><u>排序数组相关的查找问题，首先就是想到二分查找及其各种变式。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缺失数字为第一个数字的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缺失数字为最后一个数字的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] == n - <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题54-二叉搜索树的第k大节点"><a href="#面试题54-二叉搜索树的第k大节点" class="headerlink" title="面试题54.二叉搜索树的第k大节点"></a>面试题54.二叉搜索树的第k大节点</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof</a></p>
<hr>
<h3 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h3><p><u><strong>二叉堆是每个节点都比子节点大或者小的逻辑二叉树，实际优先队列；</strong></u></p>
<p><u><strong>二叉搜索数是每个节点的左子树都比该节点小，右子树都比该节点大的实际二叉树。</strong></u></p>
<p><strong>思路：先右后左的中序遍历所得第k个节点即为所求。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        inorderTraversal(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已经找到第k大节点，递归中序遍历终止。</span></span><br><span class="line">        <span class="keyword">if</span> (k == count) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root.right,k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == count) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (k == count) ans = root.val;</span><br><span class="line">        inorderTraversal(root.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><strong>单词积累</strong></p>
<ul>
<li><strong>preorderTraversal：前序遍历</strong></li>
<li><strong>inorderTraversal：中序遍历</strong></li>
<li><strong>postorderTraversal：后序遍历</strong></li>
</ul>
<h2 id="面试题55-1-二叉树的深度"><a href="#面试题55-1-二叉树的深度" class="headerlink" title="面试题55_1.二叉树的深度"></a>面试题55_1.二叉树的深度</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<blockquote>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>返回它的最大深度 3 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof</a></p>
<hr>
<h3 id="方法一：递归回溯法-2"><a href="#方法一：递归回溯法-2" class="headerlink" title="方法一：递归回溯法"></a>方法一：递归回溯法</h3><p><strong>前中后序遍历就是典型的DFS深度优先搜索，层序遍历就是典型的BFS广度优先搜索。</strong></p>
<p><strong><u>我简直要爱死递归题中的全局变量了，妈妈再也不用担心递归方法的输入参数太多太麻烦。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth,ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans = Math.max(ans,depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        traversal(root.left);</span><br><span class="line">        traversal(root.right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题55-2-平衡二叉树"><a href="#面试题55-2-平衡二叉树" class="headerlink" title="面试题55_2.平衡二叉树"></a>面试题55_2.平衡二叉树</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<blockquote>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<blockquote>
<p>​        1<br>       / <br>     2   2<br>    / \</p>
<p>   3   3<br>  / <br> 4   4</p>
</blockquote>
<p>返回 false 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof</a></p>
<hr>
<h3 id="方法一：递归-9"><a href="#方法一：递归-9" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>如果刚做了面试题55_1来做这道题会觉得很简单，如果直接做该题可能需要一些时间来思考。</strong></p>
<p><u><strong>思路：使用递归，在每层递归方法中先判断每个节点的左右子树是不是平衡二叉树，</strong></u></p>
<p><u><strong>然后计算左右子树的深度差是否不大于1，其中计算树的深度又是另外一个递归方法。</strong></u></p>
<h4 id="时间复杂度：O-nlogn-："><a href="#时间复杂度：O-nlogn-：" class="headerlink" title="时间复杂度：O(nlogn)："></a><u><strong>时间复杂度：O(nlogn)：</strong></u></h4><p><u><strong>这个时间复杂度的计算对于递归题复杂度计算非常有参考意义，要计算的是isBalanced()方法的复杂度，该方法中：</strong></u></p>
<ul>
<li><u><strong>isBalanced()方法：递归最复杂的情况是每颗子树都平衡，则每层两个递归方法都要进入，总共向下logn层；</strong></u></li>
<li><u><strong>maxDepth()方法：递归最复杂的情况是每个节点只有一个子节点，每层只进入一个递归方法，总共向下n层。</strong></u></li>
</ul>
<p><u><strong>这两个递归方法属于嵌套关系，所以最差时间复杂度即为O(nlogn)。</strong></u></p>
<h4 id="空间复杂度：O-n-："><a href="#空间复杂度：O-n-：" class="headerlink" title="空间复杂度：O(n)："></a><strong><u>空间复杂度：O(n)：</u></strong></h4><p><u><strong>不同递归方法嵌套时，空间复杂度取最差的递归方法的空间复杂度。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = maxDepth(root.left,<span class="number">0</span>) - maxDepth(root.right,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right) &amp;&amp; gap &lt;= <span class="number">1</span> &amp;&amp; gap &gt;= -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算一棵树的深度，depth参数表示该节点的父节点的深度。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left,depth + <span class="number">1</span>),maxDepth(root.right,depth + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题56-1-数组中数字出现的次数"><a href="#面试题56-1-数组中数字出现的次数" class="headerlink" title="面试题56_1.数组中数字出现的次数"></a>面试题56_1.数组中数字出现的次数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a></p>
<hr>
<h3 id="方法一：位运算-1"><a href="#方法一：位运算-1" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p><strong>本题是<a href="https://littleforestjia.github.io/2020/12/03/%E3%80%90%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E3%80%91_136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">【力扣刷题】_136.只出现一次的数字</a>的升级，也算是巧思题，要硬记。</strong></p>
<p><u><strong>思路：记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式 xk  xk - 1 …  x2  x1 x0，其中 xi不是0就是1。</strong></u><br><u><strong>那么如果我们把 a 和 b 写成二进制的形式，xi = 1就表示ai与bi不等；xi = 0就表示ai与bi相等。</strong></u><br><u><strong>假如我们任选一个不为 0 的 xi，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，分别将两组中的数组全部异或所得到的两个异或值即为两个只出现一次的数。</strong></u><br><strong>时间复杂度：O(n)</strong><br><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找a和b的异或和中从右往左第一个为1的位</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp &amp; ans) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该位不为1则将temp中的1左移一位</span></span><br><span class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp &amp; nums[i]) == <span class="number">0</span>) &#123;<span class="comment">//该元素的该位为0</span></span><br><span class="line">                a = a ^ nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//该元素的该位为1</span></span><br><span class="line">                b = b ^ nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题56-2-数组中数字出现的次数2"><a href="#面试题56-2-数组中数字出现的次数2" class="headerlink" title="面试题56_2.数组中数字出现的次数2"></a>面试题56_2.数组中数字出现的次数2</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [3,4,3,3]<br>输出：4</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</a></p>
<hr>
<h3 id="方法一：位运算-2"><a href="#方法一：位运算-2" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p><u><strong>思路：考虑数字的二进制形式，对于出现三次的数字，各二进制位出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</strong></u></p>
<p><u><strong>总结：照这个思路来看，这个思路可以解决所有某个数字只出现一次，其他数字出现多次，要求寻找只出现一次的数字的问题。</strong></u></p>
<p><strong>时间复杂度：O(n)</strong></p>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个容量为32的数组，用来记录数组nums所有数字各个对应二进制位中1出现的次数。</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                count[j] = count[j] + (<span class="number">1</span> &amp; nums[i]);</span><br><span class="line">                nums[i] = nums[i] &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ans |= (count[i] % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题57-和为s的两个数字"><a href="#面试题57-和为s的两个数字" class="headerlink" title="面试题57.和为s的两个数字"></a>面试题57.和为s的两个数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：双指针-2"><a href="#方法一：双指针-2" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong>思路：计算双指针的和，比target大则右指针左移；比target小则左指针右移。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[left],nums[right]&#125;;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><strong><u>提醒一下，判断条件最好不要用相加后的结果，应该用target - nums[i] 跟 nums[j]比较，这样保证不会溢出。同样的例子还有二分查找，(left + right) / 2 可以用left + (rigth - left) / 2 代替。</u></strong></p>
<h2 id="面试题57-2-和为s的连续正数序列"><a href="#面试题57-2-和为s的连续正数序列" class="headerlink" title="面试题57_2.和为s的连续正数序列"></a>面试题57_2.和为s的连续正数序列</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a></p>
<hr>
<h3 id="方法一：滑动窗口-双指针"><a href="#方法一：滑动窗口-双指针" class="headerlink" title="方法一：滑动窗口(双指针)"></a>方法一：滑动窗口(双指针)</h3><p><strong>思路：使用连续整数和的计算公式：首项加末项乘以项数除以二。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = ((left + right) * (right - left + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    answer[i] = left + i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(answer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//本题为求出所有可行的解，所以得到一种答案以后，任然要使窗口滑动。</span></span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) right++;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = ans.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要：矩阵的每一行中的列数可以不同，所以在初始化矩阵时，可以先只初始化行数目。</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[size][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题58-1-翻转单词顺序"><a href="#面试题58-1-翻转单词顺序" class="headerlink" title="面试题58_1.翻转单词顺序"></a>面试题58_1.翻转单词顺序</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a></p>
<hr>
<h3 id="方法一：双指针-3"><a href="#方法一：双指针-3" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>贼简单一道题，就用最直接想到的方法，从后往前一个个找到单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> begin = n - <span class="number">1</span>,end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">' '</span> &amp;&amp; (i == n - <span class="number">1</span> || s.charAt(i + <span class="number">1</span>) == <span class="string">' '</span>)) end = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">' '</span> &amp;&amp; (i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)) &#123;</span><br><span class="line">                begin = i;</span><br><span class="line">                String temp = s.substring(begin,end);</span><br><span class="line">                sb.append(temp);</span><br><span class="line">                sb.append(<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.length() != <span class="number">0</span>) sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题58-2-左旋转字符串"><a href="#面试题58-2-左旋转字符串" class="headerlink" title="面试题58_2.左旋转字符串"></a>面试题58_2.左旋转字符串</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a></p>
<hr>
<h3 id="方法一：字符串切片"><a href="#方法一：字符串切片" class="headerlink" title="方法一：字符串切片"></a>方法一：字符串切片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String begin = s.substring(<span class="number">0</span>,n);</span><br><span class="line">        String end = s.substring(n,s.length());</span><br><span class="line">        <span class="keyword">return</span> end + begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题59-1-滑动窗口的最大值"><a href="#面试题59-1-滑动窗口的最大值" class="headerlink" title="面试题59_1.滑动窗口的最大值"></a>面试题59_1.滑动窗口的最大值</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<blockquote>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a></p>
<hr>
<h3 id="方法一：辅助队列"><a href="#方法一：辅助队列" class="headerlink" title="方法一：辅助队列"></a>方法一：辅助队列</h3><p><strong>思想上和<a href="https://littleforestjia.github.io/2021/01/05/%E3%80%90%E5%89%91%E6%8C%87%E5%88%B7%E9%A2%98%E3%80%91_%E9%9D%A2%E8%AF%95%E9%A2%9830.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/" target="_blank" rel="noopener">【剑指刷题】_面试题30.包含min函数的栈</a>是一样的，借助一个辅助数据结构来保存滑动窗口在每个状态下的最大值。</strong></p>
<p><strong><u>辅助队列中只保存滑动窗口中从左到右依次最大的值。每次滑动窗口删除一个值时，先验证该值是不是辅助队列最左端的值，是则删除；滑动窗口添加元素时，检验新元素是否比辅助队列右端的值大，是则先将比新元素小的值都删除，然后加上新元素。</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                queue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = queue.peekFirst();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() == nums[i - k]) queue.removeFirst();</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                queue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(nums[i]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = queue.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题59-2-队列的最大值"><a href="#面试题59-2-队列的最大值" class="headerlink" title="面试题59_2.队列的最大值"></a>面试题59_2.队列的最大值</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，<strong>要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)</strong>。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<blockquote>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p>
<hr>
<h3 id="方法一：辅助队列-1"><a href="#方法一：辅助队列-1" class="headerlink" title="方法一：辅助队列"></a>方法一：辅助队列</h3><p><strong>思路与面试题59_1相同，只不过滑动窗口变成了队列。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; helpQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.helpQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> helpQueue.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!helpQueue.isEmpty() &amp;&amp; helpQueue.peekLast() &lt; value) &#123;</span><br><span class="line">            helpQueue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        helpQueue.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (helpQueue.peekFirst() == ans) helpQueue.removeFirst();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题60-n个骰子的点数"><a href="#面试题60-n个骰子的点数" class="headerlink" title="面试题60.n个骰子的点数"></a>面试题60.n个骰子的点数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1<br>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-6"><a href="#方法一：动态规划-6" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><strong>骰子数量为n时，可能的骰子点树分布情况有6^n种，点数和的可能值则为n~6n，返回数组的大小即为6n-n+1。</strong></p>
<p><u><strong>思路：注意此处动态规划的关键是，我们不是用概率值来作为状态，而是用出现种数来作为状态值。</strong></u></p>
<p><u><strong>状态转移方程：dp[n][j]=  (6/∑/i=1)  dp[n−1][j−i]</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span> * n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态：dp[i][j]表示用n个骰子掷出点数和为j时，有多少种不同的骰子点数分布情况，要考虑每个骰子的编号不同。</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span> * i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">6</span> * n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//这里要限定好i-1个骰子能掷出的点数和的范围</span></span><br><span class="line">                    <span class="keyword">if</span> (j - k &gt;= i - <span class="number">1</span> &amp;&amp; j - k &lt;= <span class="number">6</span> * i - <span class="number">6</span>) dp[i][j] = dp[i][j] + dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出总种数6^n</span></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum *= <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans[i] = dp[n][i + n] / sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题61-扑克牌中的顺子"><a href="#面试题61-扑克牌中的顺子" class="headerlink" title="面试题61.扑克牌中的顺子"></a>面试题61.扑克牌中的顺子</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [1,2,3,4,5]<br>输出: True</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [0,0,1,2,5]<br>输出: True</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p>
<hr>
<h3 id="方法一：排序-遍历"><a href="#方法一：排序-遍历" class="headerlink" title="方法一：排序+遍历"></a>方法一：排序+遍历</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路，不要从正面找，从反面找不是顺子的情况，那么反面主要有两类：有重复数字、最大值-最小值&gt;=5。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//joker用于记录大小王的个数</span></span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出大小王个数，并判断有无重复数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                joker = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; <span class="number">5</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (joker == <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无重复数字的情况下，最大值减最小值必须小于5才是顺子。</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62.圆圈中最后剩下的数字"></a>面试题62.圆圈中最后剩下的数字</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: n = 5, m = 3<br>输出: 3</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: n = 10, m = 17<br>输出: 2</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a></p>
<hr>
<h3 id="方法一：递归-10"><a href="#方法一：递归-10" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><u><strong>好家伙这不是典型的约瑟夫环问题吗？巧思题，要硬记。</strong></u></p>
<p><strong>n个数字从0位置开始每m个数字删除一个数字：这个过程，在删除了第一个数字(m-1)%n之后，就相当于n-1个数字从(m-1)%n位置开始每m个数字删除一个数字。</strong></p>
<p><strong>那么<u>n-1个数字从(m-1)%n位置开始每m个数字删除一个数字</u>，<u>n-1个数字从0位置开始每m个数字删除一个数字</u>，这两个过程的关系其实就是<u>起点相差(m-1)%n</u>,步长相同，那么<u>最后留下的这个数字的位置索引也就是相差(m-1)%n</u>。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = lastRemaining(n - <span class="number">1</span>,m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//index为最后留下的数字在删除了m%n位置的数字之后的n-1个数字中的位置索引。</span></span><br><span class="line">        <span class="keyword">int</span> index = ((m - <span class="number">1</span>) % n + x) % (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; (m - <span class="number">1</span>) % n) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题63-股票的最大利润"><a href="#面试题63-股票的最大利润" class="headerlink" title="面试题63.股票的最大利润"></a>面试题63.股票的最大利润</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-7"><a href="#方法一：动态规划-7" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态与初始化：dp[i]表示第i天卖出所能收获的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp = Math.max(dp + prices[i] - prices[i - <span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">            ans = Math.max(ans,dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题64-求前n个正整数之和"><a href="#面试题64-求前n个正整数之和" class="headerlink" title="面试题64.求前n个正整数之和"></a>面试题64.求前n个正整数之和</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入: n = 3<br>输出: 6</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入: n = 9<br>输出: 45</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p>
<hr>
<h3 id="方法一：递归-11"><a href="#方法一：递归-11" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sumNums(n - <span class="number">1</span>) + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h3><p><strong>这个方法又叫俄罗斯农民乘法，一种不使用*，而使用位运算的乘法。</strong></p>
<p><strong><u>思路：考虑 A 和 B 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 B 二进制展开，如果 B 的二进制表示下第 i 位为 1，那么这一位对最后结果的贡献就是 A*(1&lt;&lt;i) ，即 A&lt;&lt;i。我们遍历 B 二进制展开下的每一位，将所有贡献累加起来就是最后的答案。</u></strong></p>
<p><strong>因为题目数据范围 n 为 [1,10000]，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14 层代替循环即可。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题65-不用加减乘除做加法"><a href="#面试题65-不用加减乘除做加法" class="headerlink" title="面试题65.不用加减乘除做加法"></a>面试题65.不用加减乘除做加法</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>示例:</p>
<blockquote>
<p>输入: a = 1, b = 1<br>输出: 2</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof</a></p>
<hr>
<h3 id="方法一：位运算-3"><a href="#方法一：位运算-3" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>在计算机系统中，数值一律用补码来表示和存储。补码的优势： 加法、减法可以统一处理（CPU只有加法器）。也就是说计算机已经帮我们做好了负数的补码操作，我们在进行位运算时不用考虑什么正负数、最高位，直接每一位平等对待就好了。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可以自己列表查看四种情况，0&amp;0=0、0&amp;1=0、1&amp;0=0、1&amp;1=1，</span></span><br><span class="line">            <span class="comment">//可以看出两个数的对应位进行与运算的结果其实就是它们相加后是否进位的结果，</span></span><br><span class="line">            <span class="comment">//所以我们将该结果左移一位其实就是相加后的进位值。</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可以自己列表查看四种情况，0^0=0、0^1=1、1^0=1、1^1=0，</span></span><br><span class="line">            <span class="comment">//可以看出两个数的对应位进行异或运算的结果其实就是它们相加后，不考虑进位时，本位的结果。</span></span><br><span class="line">            a = a ^ b;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将进位结果赋值给b，在下一次循环中将进位值与不进位结果相加。</span></span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题66-构建乘积数组"><a href="#面试题66-构建乘积数组" class="headerlink" title="面试题66.构建乘积数组"></a>面试题66.构建乘积数组</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。<strong>不能使用除法。</strong></p>
<p>示例:</p>
<blockquote>
<p>输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof</a></p>
<hr>
<h3 id="方法一：动态规划-8"><a href="#方法一：动态规划-8" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><u><strong>巧思题，要硬记。</strong></u></p>
<p><u><strong>思路：结果数组中每个元素=左边所有元素的乘积*右边所有元素的乘积，第一次遍历求出每个元素对应的左边所有元素乘积，第二次遍历再乘上每个元素对应右边所有元素乘积。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次遍历</span></span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次遍历</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right = right * a[i + <span class="number">1</span>];</span><br><span class="line">            ans[i] = ans[i] * right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题67-把字符串转换成整数"><a href="#面试题67-把字符串转换成整数" class="headerlink" title="面试题67.把字符串转换成整数"></a>面试题67.把字符串转换成整数</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “42”<br>输出: 42</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
</blockquote>
<p>示例 4:</p>
<blockquote>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p>
</blockquote>
<p>示例 5:</p>
<blockquote>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p>
<hr>
<h3 id="方法一：大数字符串转换成整数"><a href="#方法一：大数字符串转换成整数" class="headerlink" title="方法一：大数字符串转换成整数"></a>方法一：大数字符串转换成整数</h3><p><u><strong>int类型数值范围为 [−231,  231 − 1]。</strong></u></p>
<p><u><strong>本题的关键难点是将超过int边界甚至是long边界的大数转换为int类型数值，采用将每一位从左往右一个一个加上的方式，这样也有利于设定到达int边界条件。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到第一个不为' '的字符的位置</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str.charAt(begin) == <span class="string">' '</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">            <span class="keyword">if</span> (begin == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(begin) == <span class="string">'+'</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(begin) == <span class="string">'-'</span>) &#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            begin ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">'0'</span> || str.charAt(i) &gt; <span class="string">'9'</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//ans接下来将要越界的两种情况。</span></span><br><span class="line">            <span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE / <span class="number">10</span> || (ans == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; str.charAt(i) &gt; <span class="string">'7'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + (str.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题68-1-二叉搜索树的最近公共祖先"><a href="#面试题68-1-二叉搜索树的最近公共祖先" class="headerlink" title="面试题68_1.二叉搜索树的最近公共祖先"></a>面试题68_1.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1:</p>
<blockquote>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof</a></p>
<hr>
<h3 id="方法一：递归-12"><a href="#方法一：递归-12" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p><strong>沿着根节点往下走，直到给定的两个节点，一个是该根节点的子节点、一个不是，则该根节点的父节点即为最近公共祖先。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSon(root.left,p) &amp;&amp; isSon(root.left,q)) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isSon(root.right,p) &amp;&amp; isSon(root.right,q)) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断节点node是不是root节点的子孙</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSon</span><span class="params">(TreeNode root,TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == node) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSon(root.left,node) || isSon(root.right,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p><strong>我自己写的方法一并没有用到二叉搜索树的特性，方法二中用到了，可以极大降低空间复杂度和时间复杂度。</strong></p>
<p><strong>二叉搜索树的特性是左子树全部小于根节点，右子树全部大于根节点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题68-2-二叉树的最近公共祖先"><a href="#面试题68-2-二叉树的最近公共祖先" class="headerlink" title="面试题68_2.二叉树的最近公共祖先"></a>面试题68_2.二叉树的最近公共祖先</h2><p><em>tips：代码块中的注解、加粗、下划线部分为重点内容。</em></p>
<hr>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p>示例 1:</p>
<blockquote>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof</a></p>
<hr>
<h3 id="方法一：递归-13"><a href="#方法一：递归-13" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSon(root.left,p) &amp;&amp; isSon(root.left,q)) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isSon(root.right,p) &amp;&amp; isSon(root.right,q)) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断节点node是不是root节点的子孙</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSon</span><span class="params">(TreeNode root,TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == node) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSon(root.left,node) || isSon(root.right,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/05/%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91_AJAX/" rel="next" title="【基础知识】_AJAX">
                <i class="fa fa-chevron-left"></i> 【基础知识】_AJAX
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/18/%E3%80%90%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E3%80%91_%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9_%E4%B8%80%E7%A7%8D%E9%97%B4%E6%8E%A5%E7%83%AD%E6%88%90%E5%9E%8B%E6%B6%B2%E5%8E%8B%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/" rel="prev" title="【科研项目】_发明专利_一种间接热成型液压机控制系统">
                【科研项目】_发明专利_一种间接热成型液压机控制系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="zju岩手县小森" />
            
              <p class="site-author-name" itemprop="name">zju岩手县小森</p>
              <p class="site-description motion-element" itemprop="description">看的远固然重要 但是走好眼前的路才是关键</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/littleforestjia" target="_blank" title="Instagram">
                      Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/29623500" target="_blank" title="Bilibili">
                      Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题2-实现singleton模式"><span class="nav-number">1.</span> <span class="nav-text">面试题2.实现singleton模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-题目"><span class="nav-number">1.1.</span> <span class="nav-text">1. 题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-单例模式"><span class="nav-number">1.2.</span> <span class="nav-text">2.单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-额外知识"><span class="nav-number">1.3.</span> <span class="nav-text">3. 额外知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-方法一：饿汉模式"><span class="nav-number">1.4.</span> <span class="nav-text">4. 方法一：饿汉模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-方法二：静态内部类"><span class="nav-number">1.5.</span> <span class="nav-text">5. 方法二：静态内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题3-数组中重复的数字"><span class="nav-number">2.</span> <span class="nav-text">面试题3.数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：遍历数组"><span class="nav-number">2.1.</span> <span class="nav-text">方法一：遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：原地置换-剑指offer原答案"><span class="nav-number">2.2.</span> <span class="nav-text">方法二：原地置换(剑指offer原答案)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题4-二维数组中的查找"><span class="nav-number">3.</span> <span class="nav-text">面试题4.二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：暴力法"><span class="nav-number">3.1.</span> <span class="nav-text">方法一：暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：线性查找"><span class="nav-number">3.2.</span> <span class="nav-text">方法二：线性查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题5-替换空格"><span class="nav-number">4.</span> <span class="nav-text">面试题5.替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题6-从尾到头打印链表"><span class="nav-number">5.</span> <span class="nav-text">面试题6.从尾到头打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：栈"><span class="nav-number">5.1.</span> <span class="nav-text">方法一：栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题7-重建二叉树"><span class="nav-number">6.</span> <span class="nav-text">面试题7.重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归"><span class="nav-number">6.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题9-用两个栈实现队列"><span class="nav-number">7.</span> <span class="nav-text">面试题9.用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双栈"><span class="nav-number">7.1.</span> <span class="nav-text">方法一：双栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题10-1-斐波那契数列"><span class="nav-number">8.</span> <span class="nav-text">面试题10_1.斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-1"><span class="nav-number">8.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划"><span class="nav-number">8.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题10-2-青蛙跳台阶问题"><span class="nav-number">9.</span> <span class="nav-text">面试题10_2.青蛙跳台阶问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划"><span class="nav-number">9.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题11-旋转数组的最小数字"><span class="nav-number">10.</span> <span class="nav-text">面试题11.旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二分搜索"><span class="nav-number">10.1.</span> <span class="nav-text">方法一：二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">10.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题12-矩阵中的路径"><span class="nav-number">11.</span> <span class="nav-text">面试题12.矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法"><span class="nav-number">11.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">11.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题13-机器人的运动范围"><span class="nav-number">12.</span> <span class="nav-text">面试题13.机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-1"><span class="nav-number">12.1.</span> <span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">12.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题14-1-剪绳子"><span class="nav-number">13.</span> <span class="nav-text">面试题14_1.剪绳子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：高数推导"><span class="nav-number">13.1.</span> <span class="nav-text">方法一：高数推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-1"><span class="nav-number">13.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题14-2-剪绳子2"><span class="nav-number">14.</span> <span class="nav-text">面试题14_2.剪绳子2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：高数推导-1"><span class="nav-number">14.1.</span> <span class="nav-text">方法一：高数推导</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题15-二进制中1的个数"><span class="nav-number">15.</span> <span class="nav-text">面试题15.二进制中1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：位运算"><span class="nav-number">15.1.</span> <span class="nav-text">方法一：位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java位运算之左移、右移与无符号右移"><span class="nav-number">15.2.</span> <span class="nav-text">java位运算之左移、右移与无符号右移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题16-数值的整数次方"><span class="nav-number">16.</span> <span class="nav-text">面试题16.数值的整数次方</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-二分法"><span class="nav-number">16.1.</span> <span class="nav-text">方法一：递归+二分法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题17-打印从1到最大的n位数"><span class="nav-number">17.</span> <span class="nav-text">面试题17.打印从1到最大的n位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-2"><span class="nav-number">17.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">17.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题18-删除链表的节点"><span class="nav-number">18.</span> <span class="nav-text">面试题18.删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一："><span class="nav-number">18.1.</span> <span class="nav-text">方法一：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题19-正则表达式匹配"><span class="nav-number">19.</span> <span class="nav-text">面试题19.正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-3"><span class="nav-number">19.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：动态规划-2"><span class="nav-number">19.2.</span> <span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">20.</span> <span class="nav-text">面试题21.调整数组顺序使奇数位于偶数前面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针"><span class="nav-number">20.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题22-链表中倒数第k个节点"><span class="nav-number">21.</span> <span class="nav-text">面试题22.链表中倒数第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：栈-1"><span class="nav-number">21.1.</span> <span class="nav-text">方法一：栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双指针"><span class="nav-number">21.2.</span> <span class="nav-text">方法二：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题24-反转链表"><span class="nav-number">22.</span> <span class="nav-text">面试题24.反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-4"><span class="nav-number">22.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双指针-1"><span class="nav-number">22.2.</span> <span class="nav-text">方法二：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题25-合并两个排序的链表"><span class="nav-number">23.</span> <span class="nav-text">面试题25.合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-5"><span class="nav-number">23.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题26-树的子结构"><span class="nav-number">24.</span> <span class="nav-text">面试题26.树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：前序遍历-递归"><span class="nav-number">24.1.</span> <span class="nav-text">方法一：前序遍历+递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题27-二叉树的镜像"><span class="nav-number">25.</span> <span class="nav-text">面试题27.二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-6"><span class="nav-number">25.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题28-对称的二叉树"><span class="nav-number">26.</span> <span class="nav-text">面试题28.对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-7"><span class="nav-number">26.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题29-顺时针打印矩阵"><span class="nav-number">27.</span> <span class="nav-text">面试题29.顺时针打印矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：按层模拟"><span class="nav-number">27.1.</span> <span class="nav-text">方法一：按层模拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题30-包含min函数的栈"><span class="nav-number">28.</span> <span class="nav-text">面试题30.包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双栈-1"><span class="nav-number">28.1.</span> <span class="nav-text">方法一：双栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题31-栈的压入弹出序列"><span class="nav-number">29.</span> <span class="nav-text">面试题31.栈的压入弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助栈"><span class="nav-number">29.1.</span> <span class="nav-text">方法一：辅助栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-1-从上到下打印二叉树"><span class="nav-number">30.</span> <span class="nav-text">面试题32_1.从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：队列"><span class="nav-number">30.1.</span> <span class="nav-text">方法一：队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-2-从上到下打印二叉树2"><span class="nav-number">31.</span> <span class="nav-text">面试题32_2.从上到下打印二叉树2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：队列-1"><span class="nav-number">31.1.</span> <span class="nav-text">方法一：队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-3-从上到下打印二叉树3"><span class="nav-number">32.</span> <span class="nav-text">面试题32_3.从上到下打印二叉树3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：队列-双端链表"><span class="nav-number">32.1.</span> <span class="nav-text">方法一：队列+双端链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：双端队列-链表"><span class="nav-number">32.2.</span> <span class="nav-text">方法二：双端队列+链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-4"><span class="nav-number">32.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题33-二叉搜索树的后序遍历序列"><span class="nav-number">33.</span> <span class="nav-text">面试题33.二叉搜索树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-8"><span class="nav-number">33.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：官方答案"><span class="nav-number">33.2.</span> <span class="nav-text">方法二：官方答案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题34-二叉树中和为某一值的路径"><span class="nav-number">34.</span> <span class="nav-text">面试题34.二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-1"><span class="nav-number">34.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题35-复杂链表的复制"><span class="nav-number">35.</span> <span class="nav-text">面试题35.复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：哈希表"><span class="nav-number">35.1.</span> <span class="nav-text">方法一：哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：拼接与拆分"><span class="nav-number">35.2.</span> <span class="nav-text">方法二：拼接与拆分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题36-二叉搜索树与双向链表"><span class="nav-number">36.</span> <span class="nav-text">面试题36.二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归中序遍历"><span class="nav-number">36.1.</span> <span class="nav-text">方法一：递归中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题37-序列化二叉树"><span class="nav-number">37.</span> <span class="nav-text">面试题37.序列化二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：层序遍历"><span class="nav-number">37.1.</span> <span class="nav-text">方法一：层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-5"><span class="nav-number">37.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题38-字符串的排列"><span class="nav-number">38.</span> <span class="nav-text">面试题38.字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯-剪枝"><span class="nav-number">38.1.</span> <span class="nav-text">方法一：递归回溯+剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题39-数组中出现次数超过一半的数字"><span class="nav-number">39.</span> <span class="nav-text">面试题39.数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：中位数"><span class="nav-number">39.1.</span> <span class="nav-text">方法一：中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：摩尔投票法"><span class="nav-number">39.2.</span> <span class="nav-text">方法二：摩尔投票法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题40-最小的k个数"><span class="nav-number">40.</span> <span class="nav-text">面试题40.最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序"><span class="nav-number">40.1.</span> <span class="nav-text">方法一：排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：堆排序"><span class="nav-number">40.2.</span> <span class="nav-text">方法二：堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：快速排序"><span class="nav-number">40.3.</span> <span class="nav-text">方法三：快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-6"><span class="nav-number">40.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题41-数据流中的中位数"><span class="nav-number">41.</span> <span class="nav-text">面试题41.数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二叉堆-优先队列"><span class="nav-number">41.1.</span> <span class="nav-text">方法一：二叉堆&#x2F;优先队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题42-连续子数组的最大和"><span class="nav-number">42.</span> <span class="nav-text">面试题42.连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-2"><span class="nav-number">42.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题43-前n个整数中1出现的次数"><span class="nav-number">43.</span> <span class="nav-text">面试题43.前n个整数中1出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：迭代"><span class="nav-number">43.1.</span> <span class="nav-text">方法一：迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题44-数字序列中某一位的数字"><span class="nav-number">44.</span> <span class="nav-text">面试题44.数字序列中某一位的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：找规律"><span class="nav-number">44.1.</span> <span class="nav-text">方法一：找规律</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题45-把数组排成最小的数"><span class="nav-number">45.</span> <span class="nav-text">面试题45.把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：快速排序"><span class="nav-number">45.1.</span> <span class="nav-text">方法一：快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：使用JDK工具类排序"><span class="nav-number">45.2.</span> <span class="nav-text">方法二：使用JDK工具类排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题46-把数字翻译成字符串"><span class="nav-number">46.</span> <span class="nav-text">面试题46.把数字翻译成字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-3"><span class="nav-number">46.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题47-礼物的最大价值"><span class="nav-number">47.</span> <span class="nav-text">面试题47.礼物的最大价值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-4"><span class="nav-number">47.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题48-最长不含重复字符的子字符串"><span class="nav-number">48.</span> <span class="nav-text">面试题48.最长不含重复字符的子字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：滑动窗口"><span class="nav-number">48.1.</span> <span class="nav-text">方法一：滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题49-丑数"><span class="nav-number">49.</span> <span class="nav-text">面试题49.丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-5"><span class="nav-number">49.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题50-第一个只出现一次的字符"><span class="nav-number">50.</span> <span class="nav-text">面试题50.第一个只出现一次的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：HashMap"><span class="nav-number">50.1.</span> <span class="nav-text">方法一：HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-7"><span class="nav-number">50.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题51-数组中的逆序对"><span class="nav-number">51.</span> <span class="nav-text">面试题51.数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：归并排序"><span class="nav-number">51.1.</span> <span class="nav-text">方法一：归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题52-两个链表的第一个公共节点"><span class="nav-number">52.</span> <span class="nav-text">面试题52.两个链表的第一个公共节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-1"><span class="nav-number">52.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题53-1-在排序数组中查找数字"><span class="nav-number">53.</span> <span class="nav-text">面试题53_1.在排序数组中查找数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二分查找"><span class="nav-number">53.1.</span> <span class="nav-text">方法一：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题53-2-前n个数中缺失的数字"><span class="nav-number">54.</span> <span class="nav-text">面试题53_2.前n个数中缺失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：二分查找-1"><span class="nav-number">54.1.</span> <span class="nav-text">方法一：二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题54-二叉搜索树的第k大节点"><span class="nav-number">55.</span> <span class="nav-text">面试题54.二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：中序遍历"><span class="nav-number">55.1.</span> <span class="nav-text">方法一：中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-8"><span class="nav-number">55.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题55-1-二叉树的深度"><span class="nav-number">56.</span> <span class="nav-text">面试题55_1.二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归回溯法-2"><span class="nav-number">56.1.</span> <span class="nav-text">方法一：递归回溯法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题55-2-平衡二叉树"><span class="nav-number">57.</span> <span class="nav-text">面试题55_2.平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-9"><span class="nav-number">57.1.</span> <span class="nav-text">方法一：递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：O-nlogn-："><span class="nav-number">57.1.1.</span> <span class="nav-text">时间复杂度：O(nlogn)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：O-n-："><span class="nav-number">57.1.2.</span> <span class="nav-text">空间复杂度：O(n)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题56-1-数组中数字出现的次数"><span class="nav-number">58.</span> <span class="nav-text">面试题56_1.数组中数字出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：位运算-1"><span class="nav-number">58.1.</span> <span class="nav-text">方法一：位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题56-2-数组中数字出现的次数2"><span class="nav-number">59.</span> <span class="nav-text">面试题56_2.数组中数字出现的次数2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：位运算-2"><span class="nav-number">59.1.</span> <span class="nav-text">方法一：位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题57-和为s的两个数字"><span class="nav-number">60.</span> <span class="nav-text">面试题57.和为s的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-2"><span class="nav-number">60.1.</span> <span class="nav-text">方法一：双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-9"><span class="nav-number">60.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题57-2-和为s的连续正数序列"><span class="nav-number">61.</span> <span class="nav-text">面试题57_2.和为s的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：滑动窗口-双指针"><span class="nav-number">61.1.</span> <span class="nav-text">方法一：滑动窗口(双指针)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题58-1-翻转单词顺序"><span class="nav-number">62.</span> <span class="nav-text">面试题58_1.翻转单词顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：双指针-3"><span class="nav-number">62.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题58-2-左旋转字符串"><span class="nav-number">63.</span> <span class="nav-text">面试题58_2.左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：字符串切片"><span class="nav-number">63.1.</span> <span class="nav-text">方法一：字符串切片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题59-1-滑动窗口的最大值"><span class="nav-number">64.</span> <span class="nav-text">面试题59_1.滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助队列"><span class="nav-number">64.1.</span> <span class="nav-text">方法一：辅助队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题59-2-队列的最大值"><span class="nav-number">65.</span> <span class="nav-text">面试题59_2.队列的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：辅助队列-1"><span class="nav-number">65.1.</span> <span class="nav-text">方法一：辅助队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题60-n个骰子的点数"><span class="nav-number">66.</span> <span class="nav-text">面试题60.n个骰子的点数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-6"><span class="nav-number">66.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题61-扑克牌中的顺子"><span class="nav-number">67.</span> <span class="nav-text">面试题61.扑克牌中的顺子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：排序-遍历"><span class="nav-number">67.1.</span> <span class="nav-text">方法一：排序+遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题62-圆圈中最后剩下的数字"><span class="nav-number">68.</span> <span class="nav-text">面试题62.圆圈中最后剩下的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-10"><span class="nav-number">68.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题63-股票的最大利润"><span class="nav-number">69.</span> <span class="nav-text">面试题63.股票的最大利润</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-7"><span class="nav-number">69.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题64-求前n个正整数之和"><span class="nav-number">70.</span> <span class="nav-text">面试题64.求前n个正整数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-11"><span class="nav-number">70.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：位运算"><span class="nav-number">70.2.</span> <span class="nav-text">方法二：位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题65-不用加减乘除做加法"><span class="nav-number">71.</span> <span class="nav-text">面试题65.不用加减乘除做加法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：位运算-3"><span class="nav-number">71.1.</span> <span class="nav-text">方法一：位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题66-构建乘积数组"><span class="nav-number">72.</span> <span class="nav-text">面试题66.构建乘积数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：动态规划-8"><span class="nav-number">72.1.</span> <span class="nav-text">方法一：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题67-把字符串转换成整数"><span class="nav-number">73.</span> <span class="nav-text">面试题67.把字符串转换成整数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：大数字符串转换成整数"><span class="nav-number">73.1.</span> <span class="nav-text">方法一：大数字符串转换成整数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题68-1-二叉搜索树的最近公共祖先"><span class="nav-number">74.</span> <span class="nav-text">面试题68_1.二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-12"><span class="nav-number">74.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：递归"><span class="nav-number">74.2.</span> <span class="nav-text">方法二：递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题68-2-二叉树的最近公共祖先"><span class="nav-number">75.</span> <span class="nav-text">面试题68_2.二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：递归-13"><span class="nav-number">75.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zju岩手县小森</span>

  
</div>















        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
